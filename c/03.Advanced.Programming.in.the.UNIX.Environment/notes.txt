# Advanced Programming in the UNIX® Environment

Third Edition

src.3e.tar.gz was downloaded from http://www.apuebook.com/code3e.html
It contains source code for the book Advanced Programming in the UNIX® Environment, Third Edition
tar -zxvf src.3e.tar.gz get apeu direcotry.
In this repository, I renamed the direcotries according to chapters in the book, also formated the c code for learning purpose.

## Contents

Foreword to the Second Edition xix

Preface xxi

Preface to the Second Edition xxv

Preface to the First Edition xxix

Chapter 1. UNIX System Overview 1

1.1 Introduction 1

1.2 UNIX Architecture 1

1.3 Logging In 2

1.4 Files and Directories 4

1.5 Input and Output 8

1.6 Programs and Processes 10

1.7 Error Handling 14

1.8 User Identification 16

1.9 Signals 18

1.10 Time Values 20

1.11 System Calls and Librar y Functions 21

1.12 Summary 23

Chapter 2. UNIX Standardization and Implementations 25

2.1 Introduction 25

2.2 UNIX Standardization 25

2.2.1 ISO C 25

2.2.2 IEEE POSIX 26

2.2.3 The Single UNIX Specification 30

2.2.4 FIPS 32

2.3 UNIX System Implementations 33

2.3.1 UNIX System V Release 4 33

2.3.2 4.4BSD 34

2.3.3 FreeBSD 34

2.3.4 Linux 35

2.3.5 Mac OS X 35

2.3.6 Solaris 35

2.3.7 Other UNIX Systems 35

2.4 Relationship of Standards and Implementations 36

2.5 Limits 36

2.5.1 ISO C Limits 37

2.5.2 POSIX Limits 38

2.5.3 XSI Limits 41

2.5.4 sysconf, pathconf, and fpathconf Functions 42

2.5.5 Indeterminate Runtime Limits 49

2.6 Options 53

2.7 Feature Test Macros 57

2.8 Primitive System Data Types 58

2.9 Differences Between Standards 58

2.10 Summary 60

Chapter 3. File I/O 61

3.1 Introduction 61

3.2 File Descr iptors 61

3.3 open and openat Functions 62

3.4 creat Function 66

3.5 close Function 66

3.6 lseek Function 66

3.7 read Function 71

3.8 write Function 72

3.9 I/O Efficiency 72

3.10 File Sharing 74

3.11 Atomic Operations 77

3.12 dup and dup2 Functions 79

3.13 sync, fsync, and fdatasync Functions 81

3.14 fcntl Function 82

3.15 ioctl Function 87

3.16 /dev/fd 88

3.17 Summary 90

Chapter 4. Files and Directories 93

4.1 Introduction 93

4.2 stat, fstat, fstatat, and lstat Functions 93

4.3 File Types 95

4.4 Set-User-ID and Set-Group-ID 98

4.5 File Access Per missions 99

4.6 Ownership of New Files and Directories 101

4.7 access and faccessat Functions 102

4.8 umask Function 104

4.9 chmod, fchmod, and fchmodat Functions 106

4.10 Sticky Bit 108

4.11 chown, fchown, fchownat, and lchown Functions 109

4.12 File Size 111

4.13 File Tr uncation 112

4.14 File Systems 113

4.15 link, linkat, unlink, unlinkat, and remove Functions 116

4.16 rename and renameat Functions 119

4.17 Symbolic Links 120

4.18 Creating and Reading Symbolic Links 123

4.19 File Times 124

4.20 futimens, utimensat, and utimes Functions 126

4.21 mkdir, mkdirat, and rmdir Functions 129

4.22 Reading Director ies 130

4.23 chdir, fchdir, and getcwd Functions 135

4.24 Device Special Files 137

4.25 Summary of File Access Per mission Bits 140

4.26 Summary 140

Chapter 5. Standard I/O Library 143

5.1 Introduction 143

5.2 Streams and FILE Objects 143

5.3 Standard Input, Standard Output, and Standard Error 145

5.4 Buffer ing 145

5.5 Opening a Stream 148

5.6 Reading and Writing a Stream 150

5.7 Line-at-a-Time I/O 152

5.8 Standard I/O Efficiency 153

5.9 Binary I/O 156

5.10 Positioning a Stream 157

5.11 For matted I/O 159

5.12 Implementation Details 164

5.13 Temporar y Files 167

5.14 Memory Streams 171

5.15 Alternatives to Standard I/O 174

5.16 Summary 175

Chapter 6. System Data Files and Information 177

6.1 Introduction 177

6.2 Password File 177

6.3 Shadow Passwords 181

6.4 Group File 182

6.5 Supplementary Group IDs 183

6.6 Implementation Differences 184

6.7 Other Data Files 185

6.8 Login Accounting 186

6.9 System Identification 187

6.10 Time and Date Routines 189

6.11 Summary 196

Chapter 7. Process Environment 197

7.1 Introduction 197

7.2 main Function 197

7.3 Process Termination 198

7.4 Command-Line Arguments 203

7.5 Environment List 203

7.6 Memory Lay out of a C Program 204

7.7 Shared Librar ies 206

7.8 Memory Allocation 207

7.9 Environment Var iables 210

7.10 setjmp and longjmp Functions 213

7.11 getrlimit and setrlimit Functions 220

7.12 Summary 225

Chapter 8. Process Control 227

8.1 Introduction 227

8.2 Process Identifiers 227

8.3 fork Function 229

8.4 vfork Function 234

8.5 exit Functions 236

8.6 wait and waitpid Functions 238

8.7 waitid Function 244

8.8 wait3 and wait4 Functions 245

8.9 Race Conditions 245

8.10 exec Functions 249

8.11 Changing User IDs and Group IDs 255

8.12 Interpreter Files 260

8.13 system Function 264

8.14 Process Accounting 269

8.15 User Identification 275

8.16 Process Scheduling 276

8.17 Process Times 280

8.18 Summary 282

Chapter 9. Process Relationships 285

9.1 Introduction 285

9.2 Ter minal Logins 285

9.3 Networ k Logins 290

9.4 Process Groups 293

9.5 Sessions 295

9.6 Controlling Terminal 296

9.7 tcgetpgrp, tcsetpgrp, and tcgetsid Functions 298

9.8 Job Control 299

9.9 Shell Execution of Programs 303

9.10 Orphaned Process Groups 307

9.11 FreeBSD Implementation 310

9.12 Summary 312

Chapter 10. Signals 313

10.1 Introduction 313

10.2 Signal Concepts 313

10.3 signal Function 323

10.4 Unreliable Signals 326

10.5 Interrupted System Calls 327

10.6 Reentrant Functions 330

10.7 SIGCLD Semantics 332

10.8 Reliable-Signal Ter minology and Semantics 335

10.9 kill and raise Functions 336

10.10 alarm and pause Functions 338

10.11 Signal Sets 344

10.12 sigprocmask Function 346

10.13 sigpending Function 347

10.14 sigaction Function 349

10.15 sigsetjmp and siglongjmp Functions 355

10.16 sigsuspend Function 359

10.17 abort Function 365

10.18 system Function 367

10.19 sleep, nanosleep, and clock_nanosleep Functions 373

10.20 sigqueue Function 376

10.21 Job-Control Signals 377

10.22 Signal Names and Numbers 379

10.23 Summary 381

Chapter 11. Threads 383

11.1 Introduction 383

11.2 Thread Concepts 383

11.3 Thread Identification 384

11.4 Thread Creation 385

11.5 Thread Termination 388

11.6 Thread Synchronization 397

11.6.1 Mutexes 399

11.6.2 Deadlock Avoidance 402

11.6.3 pthread_mutex_timedlock Function 407

11.6.4 Reader–Writer Locks 409

11.6.5 Reader–Writer Locking with Timeouts 413

11.6.6 Condition Variables 413

11.6.7 Spin Locks 417

11.6.8 Barriers 418

11.7 Summary 422

Chapter 12. Thread Control 425

12.1 Introduction 425

12.2 Thread Limits 425

12.3 Thread Attr ibutes 426

12.4 Synchronization Attr ibutes 430

12.4.1 Mutex Attr ibutes 430

12.4.2 Reader–Writer Lock Attr ibutes 439

12.4.3 Condition Variable Attributes 440

12.4.4 Barrier Attributes 441

12.5 Reentrancy 442

12.6 Thread-Specific Data 446

12.7 Cancel Options 451

12.8 Threads and Signals 453

12.9 Threads and fork 457

12.10 Threads and I/O 461

12.11 Summary 462

Chapter 13. Daemon Processes 463

13.1 Introduction 463

13.2 Daemon Character istics 463

13.3 Coding Rules 466

13.4 Error Logging 469

13.5 Single-Instance Daemons 473

13.6 Daemon Conventions 474

13.7 Client–Server Model 479

13.8 Summary 480

Chapter 14. Advanced I/O 481

14.1 Introduction 481

14.2 Nonblocking I/O 481

14.3 Record Locking 485

14.4 I/O Multiplexing 500

14.4.1 select and pselect Functions 502

14.4.2 poll Function 506

14.5 Asynchronous I/O 509

14.5.1 System V Asynchronous I/O 510

14.5.2 BSD Asynchronous I/O 510

14.5.3 POSIX Asynchronous I/O 511

14.6 readv and writev Functions 521

14.7 readn and writen Functions 523

14.8 Memory-Mapped I/O 525

14.9 Summary 531

Chapter 15. Interprocess Communication 533

15.1 Introduction 533

15.2 Pipes 534

15.3 popen and pclose Functions 541

15.4 Coprocesses 548

15.5 FIFOs 552

15.6 XSI IPC 556

15.6.1 Identifiers and Keys 556

15.6.2 Per mission Str ucture 558

15.6.3 Configuration Limits 559

15.6.4 Advantages and Disadvantages 559

15.7 Message Queues 561

15.8 Semaphores 565

15.9 Shared Memor y 571

15.10 POSIX Semaphores 579

15.11 Client–Server Proper ties 585

15.12 Summary 587

Chapter 16. Network IPC: Sockets 589

16.1 Introduction 589

16.2 Socket Descr iptors 590

16.3 Addressing 593

16.3.1 Byte Order ing 593

16.3.2 Address Formats 595

16.3.3 Address Lookup 597

16.3.4 Associating Addresses with Sockets 604

16.4 Connection Establishment 605

16.5 Data Tr ansfer 610

16.6 Socket Options 623

16.7 Out-of-Band Data 626

16.8 Nonblocking and Asynchronous I/O 627

16.9 Summary 628

Chapter 17. Advanced IPC 629

17.1 Introduction 629

17.2 UNIX Domain Sockets 629

17.2.1 Naming UNIX Domain Sockets 634

17.3 Unique Connections 635

17.4 Passing File Descriptors 642

17.5 An Open Server, Version 1 653

17.6 An Open Server, Version 2 659

17.7 Summary 669

Chapter 18. Terminal I/O 671

18.1 Introduction 671

18.2 Over view 671

18.3 Special Input Characters 678

18.4 Getting and Setting Ter minal Attr ibutes 683

18.5 Ter minal Option Flags 683

18.6 stty Command 691

18.7 Baud Rate Functions 692

18.8 Line Control Functions 693

18.9 Ter minal Identification 694

18.10 Canonical Mode 700

18.11 Noncanonical Mode 703

18.12 Ter minal Window Size 710

18.13 termcap, terminfo, and curses 712

18.14 Summary 713

Chapter 19. Pseudo Terminals 715

19.1 Introduction 715

19.2 Over view 715

19.3 Opening Pseudo-Ter minal Devices 722

19.4 pty_fork Function 726

19.5 pty Program 729

19.6 Using the pty Program 733

19.7 Advanced Features 740

19.8 Summary 741

Chapter 20. A Database Library 743

20.1 Introduction 743

20.2 History 743

20.3 The Librar y 744

20.4 Implementation Over view 746

20.5 Centralized or Decentralized? 750

20.6 Concurrency 752

20.7 Building the Library 753

20.8 Source Code 753

20.9 Perfor mance 781

20.10 Summary 786

Chapter 21. Communicating with a Network Printer 789

21.1 Introduction 789

21.2 The Inter net Pr inting Protocol 789

21.3 The Hyper text Transfer Protocol 792

21.4 Printer Spooling 793

21.5 Source Code 795

21.6 Summary 843

Appendix A. Function Prototypes 845

Appendix B. Miscellaneous Source Code 895

B.1 Our Header File 895

B.2 Standard Error Routines 898

Appendix C. Solutions to Selected Exercises 905

Bibliography 947

Index 955


## Chapter 1. UNIX System Overview

### 1.1 Introduction

This chapter provides a whirlwind tour of the UNIX System from a programmer ’s perspective.

### 1.2 UNIX Architecture

In a strict sense, an operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run. Generally, we call this software the kernel, since it is relatively small and resides at the core of the environment. The interface to the kernel is a layer of software called the system calls.

### 1.3 Logging In

When we log in to a UNIX system, we enter our login name, followed by our password. Once we log in, some system information messages are typically displayed, and then we can type commands to the shell program.

### 1.4 Files and Directories

The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. A directory is a file that contains directory entries. The names in a directory are called filenames. A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname.

Every process has a working directory, sometimes called the current working directory. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the chdir function. When we log in, the working directory is set to our home directory.

### 1.5 Input and Output

File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.

By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error.

Unbuffered I/O is provided by the functions open, read, write, lseek, and close. These functions all work with file descriptors.

The standard I/O functions provide a buffered interface to the unbuffered I/O functions. Using standard I/O relieves us from having to choose optimal buffer sizes, such as the BUFFSIZE constant.

### 1.6 Programs and Processes

A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the seven exec functions.

An executing instance of a program is called a process, a term used on almost every page of this text. The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer.

There are three primary functions for process control: fork, exec, and waitpid.

Usually,aprocess has only one thread of control — one set of machine instructions executing at a time.  Some problems are easier to solve when more than one thread of control can operate on different parts of the problem.

All threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process.

Like processes, threads are identified by IDs. Thread IDs, however, are local to a process. A thread ID from one process has no meaning in another process.

### 1.7 Error Handling

When an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer errno is usually set to a value that tells why.

There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in <errno.h> has a value of 0.

The errors defined in <errno.h> can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user ’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. The typical recovery action for a resource-related nonfatal error is to delay and retry later.

### 1.8 User Identification

The user ID from our entry in the password file is a numeric value that identifies us to the system.

Our entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group.

There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group.

In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups.

### 1.9 Signals

Signals are a technique used to notify a process that some condition has occurred. The process has three choices for dealing with the
signal.

1. Ignore the signal.
2. Let the default action occur.
3. Provide a function that is called when the signal occurs.

### 1.10 Time Values

Historically, UNIX systems have maintained two different time values:
1. Calendar time. This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970, Coordinated Universal Time (UTC).
2. Process time. This is also called CPU time and measures the central processor resources used by a process.

UNIX System maintains three values for a process:

* Clock time
* User CPU time
* System CPU time

The clock time, sometimes called wall clock time, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process.

### 1.11 System Calls and Library Functions

All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls

The technique used on UNIX systems is for each system call to have a function of the same name in the standard C library.

### 1.12 Summary

This chapter has provided a short tour of the UNIX System.

## Chapter 2. UNIX Standardization and Implementations

### 2.1 Introduction

In this chapter we first look at the various standardization efforts that have been under way over the past two and a half decades. We then discuss the effects of these UNIX programming standards on the operating system implementations that are described in this book.

### 2.2 UNIX Standardization

#### 2.2.1 ISO C

In late 1989, ANSI Standard X3.159-1989 for the C programming language was approved. This standard was also adopted as International Standard ISO/IEC 9899:1990. ANSI is the American National Standards Institute, the U.S. member in the International Organization for Standardization (ISO). IEC stands for the International Electrotechnical Commission.

The C standard is now maintained and developed by the ISO/IEC international standardization working group for the C programming language, known as ISO/IEC JTC1/SC22/WG14, or WG14 for short.

In 1999, the ISO C standard was updated and approved as ISO/IEC 9899:1999,
largely to improve support for applications that perform numerical processing. 

The ISO C library can be divided into 24 areas, based on the headers defined by the standard.

#### 2.2.2 IEEE POSIX

POSIX is a family of standards initially developed by the IEEE (Institute of Electrical and Electronics Engineers). POSIX stands for Portable Operating System Interface. It originally referred only to the IEEE Standard 1003.1-1988 — the operating system interface — but was later extended to include many of the standards and draft standards with the 1003 designation, including the shell and utilities (1003.2).

Of specific interest to this book is the 1003.1 operating system interface standard, whose goal is to promote the portability of applications among various UNIX System environments. This standard defines the services that an operating system must provide if it is to be ‘‘POSIX compliant,’’ and has been adopted by most computer vendors.

Because the 1003.1 standard specifies an interface and not an implementation, no distinction is made between system calls and library functions. All the routines in the standard are called functions.

After more than twenty years of work, the standards are mature and stable. The POSIX.1 standard is maintained by an open working group known as the Austin Group (http://www.opengroup.org/austin). To ensure that they are still relevant, the standards need to be either updated or reaffirmed every so often.

#### 2.2.3 The Single UNIX Specification

The Single UNIX Specification, a superset of the POSIX.1 standard, specifies additional interfaces that extend the functionality provided by the POSIX.1 specification. POSIX.1 is equivalent to the Base Specifications portion of the Single UNIX Specification.

The X/Open System Interfaces (XSI) option in POSIX.1 describes optional interfaces and defines which optional portions of POSIX.1 must be supported for an implementation to be deemed XSI conforming. These include file synchronization, thread stack address and size attributes, thread process-shared synchronization, and the _XOPEN_UNIX symbolic constant . Only XSIconforming implementations can be called UNIX systems.

#### 2.2.4 FIPS

FIPS stands for Federal Information Processing Standard. It was published by the U.S. government, which used it for the procurement of computer systems.

### 2.3 UNIX System Implementations

The previous section described ISO C, IEEE POSIX, and the Single UNIX Specification — three standards originally created by independent organizations.

These standards are taken by vendors and turned into actual implementations. In this book, we are interested in both these standards and their implementation.

#### 2.3.1 UNIX System V Release 4

UNIX System V Release 4 (SVR4) was a product of AT&T’s UNIX System Laboratories (USL, formerly AT&T’s UNIX Software Operation). SVR4 merged functionality from AT&T UNIX System V Release 3.2 (SVR3.2), the SunOS operating system from Sun Microsystems, the 4.3BSD release from the University of California, and the Xenix system from Microsoft into one coherent operating system.

#### 2.3.2 4.4BSD

The Berkeley Software Distribution (BSD) releases were produced and distributed by the Computer Systems Research Group (CSRG) at the University of California at Berkeley; 4.2BSD was released in 1983 and 4.3BSD in 1986.  Both of these releases ran on the VAX minicomputer. The next release, 4.3BSD Tahoe in 1988, also ran on a particular minicomputer called the Tahoe.

#### 2.3.3 FreeBSD

FreeBSD is based on the 4.4BSD-Lite operating system. The FreeBSD project was formed to carry on the BSD line after the Computing Science Research Group at the University of California at Berkeley decided to end its work on the BSD versions of the UNIX operating system, and the 386BSD project seemed to be neglected for too long.

#### 2.3.4 Linux

Linux is an operating system that provides a rich programming environment similar to that of a UNIX System; it is freely available under the GNU Public License. The popularity of Linux is somewhat of a phenomenon in the computer industry. Linux is distinguished by often being the first operating system to support new hardware.

Linux was created in 1991 by Linus Torvalds as a replacement for MINIX. A grass-roots effort then sprang up, whereby many developers across the world volunteered their time to use and enhance it.

#### 2.3.5 Mac OS X

Mac OS X is based on entirely different technology than prior versions. The core operating system is called ‘‘Darwin,’’ and is based on a combination of the Mach kernel (Accetta et al. [1986]), the FreeBSD operating system, and an object-oriented framework for drivers and other kernel extensions. As of version 10.5, the Intel port of Mac OS X has been certified to be a UNIX system.

#### 2.3.6 Solaris

Solaris is the version of the UNIX System developed by Sun Microsystems (now Oracle). Solaris is based on System V Release 4, but includes more than fifteen years of enhancements from the engineers at Sun Microsystems. It is arguably the only commercially successful SVR4 descendant, and is formally certified to be a UNIX system.

#### 2.3.7 Other UNIX Systems

Other versions of the UNIX system that have been certified in the past include

* AIX, IBM’s version of the UNIX System
* HP-UX, Hewlett-Packard’s version of the UNIX System
* IRIX, the UNIX System version shipped by Silicon Graphics
* UnixWare, the UNIX System descended from SVR4 sold by SCO

### 2.4 Relationship of Standards and Implementations

The standards that we’ve mentioned define a subset of any actual system. The focus of this book is on four real systems: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris.

Because all four are POSIX compliant to varying degrees, we will also concentrate on the features required by the POSIX.1 standard, noting any differences between POSIX and the actual implementations of these four systems.

Be aware that the implementations provide backward compatibility for features in earlier releases, such as SVR3.2 and 4.3BSD.

### 2.5 Limits

The implementations define many magic numbers and constants. Many of these have been hard coded into programs or were determined using ad hoc techniques. With the various standardization efforts that we’ve described, more portable methods are now provided to determine these magic numbers and implementation-defined limits, greatly improving the portability of software written for the UNIX environment.

Two types of limits are needed:

1. Compile-time limits (e.g., what’s the largest value of a short integer?)
2. Runtime limits (e.g., how many bytes in a filename?)
 
#### 2.5.1 ISO C Limits

All of the compile-time limits defined by ISO C are defined in the file <limits.h>. These constants don’t change in a given system.

#### 2.5.2 POSIX Limits

POSIX.1 defines numerous constants that deal with implementation limits of the operating system. 

Although POSIX.1 defines numerous limits and constants, we’ll concern ourselves with only the ones that affect the base POSIX.1 interfaces. These limits and constants are divided into the following seven categories:

1. Numerical limits: LONG_BIT, SSIZE_MAX, and WORD_BIT
2. Minimum values: the 25 constants in Figure 2.8
3. Maximum value: _POSIX_CLOCKRES_MIN
4. Runtime increasable values: CHARCLASS_NAME_MAX, COLL_WEIGHTS_MAX, LINE_MAX, NGROUPS_MAX, and RE_DUP_MAX
5. Runtime invariant values, possibly indeterminate: 17 constants
6. Other invariant values: NL_ARGMAX, NL_MSGMAX, NL_SETMAX, and NL_TEXTMAX
7. Pathname variable values: FILESIZEBITS, LINK_MAX, MAX_CANON, MAX_INPUT, NAME_MAX, PATH_MAX, PIPE_BUF, and SYMLINK_MAX

These minimum values do not change from one system to another. They specify the most restrictive values for these features. A conforming POSIX.1 implementation must provide values that are at least this large. This is why they are called minimums, although their names all contain MAX.

#### 2.5.3 XSI Limits

The XSI option also defines constants representing implementation limits. They
include:

1. Minimum values: NL_LANGMAX, NZERO, _XOPEN_IOV_MAX, _XOPEN_NAME_MAX, _XOPEN_PATH_MAX
2. Runtime invariant values, possibly indeterminate: IOV_MAX and PAGE_SIZE

#### 2.5.4 sysconf, pathconf, and fpathconf Functions

The runtime limits are obtained by calling one of the following three functions.

```c
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);
```

1. All three functions return −1 and set errno to EINVAL if the name isn’t one of the appropriate constants. The third column in Figures 2.11 and 2.12 lists the limit constants we’ll deal with throughout the rest of this book.
2. Some names can return either the value of the variable (a return value ≥ 0) or an indication that the value is indeterminate. An indeterminate value is indicated by returning −1 and not changing the value of errno.
3. The value returned for _SC_CLK_TCK is the number of clock ticks per second, for use with the return values from the times function. 

Some restrictions apply to the pathconf pathname argument and the fpathconf
fd argument. If any of these restrictions isn’t met, the results are undefined.

1. The referenced file for _PC_MAX_CANON and _PC_MAX_INPUT must be a
terminal file.
2. The referenced file for _PC_LINK_MAX and _PC_TIMESTAMP_RESOLUTION can
be either a file or a directory. If the referenced file is a directory, the return value
applies to the directory itself, not to the filename entries within the directory.
3. The referenced file for _PC_FILESIZEBITS and _PC_NAME_MAX must be a
directory. The return value applies to filenames within the directory
4. The referenced file for _PC_PATH_MAX must be a directory. The value returned is the maximum length of a relative pathname when the specified directory is the working directory.
5. The referenced file for _PC_PIPE_BUF must be a pipe, FIFO, or directory. In the first two cases (pipe or FIFO), the return value is the limit for the referenced pipe or FIFO. For the other case (a directory), the return value is the limit for any FIFO created in that directory
6. The referenced file for _PC_SYMLINK_MAX must be a directory. The value returned is the maximum length of the string that a symbolic link in that directory can contain.

#### 2.5.5 Indeterminate Runtime Limits

We mentioned that some of the limits can be indeterminate. The problem we encounter is that if these limits aren’t defined in the <limits.h> header, we can’t use them at compile time. But they might not be defined at runtime if their value is indeterminate! Let’s look at two specific cases: allocating storage for a pathname and determining the number of file descriptors.

### 2.6 Options

If we are to write portable applications that depend on any of these optionally supported features, we need a portable way to determine whether an implementation supports a given option.  POSIX.1 defines three ways to do this.

1. Compile-time options are defined in <unistd.h>.
2. Runtime options that are not associated with a file or a directory are identified with the sysconf function.
3. Runtime options that are associated with a file or a directory are discovered by calling either the pathconf or the fpathconf function.

For each option, we have three possibilities for a platform’s support status.

1. If the symbolic constant is either undefined or defined to have the value −1, then the corresponding option is unsupported by the platform at compile time. It is possible to run an old application on a newer system where the option is supported, so a runtime check might indicate the option is supported even though the option wasn’t supported at the time the application was compiled.
2. If the symbolic constant is defined to be greater than zero, then the corresponding option is supported.
3. If the symbolic constant is defined to be equal to zero, then we must call sysconf, pathconf, or fpathconf to determine whether the option is supported.

### 2.7 Feature Test Macros

The headers define numerous POSIX.1 and XSI symbols, as we’ve described. Even so, most implementations can add their own definitions to these headers, in addition to the POSIX.1 and XSI definitions. If we want to compile a program so that it depends only on the POSIX definitions and doesn’t conflict with any implementation-defined constants, we need to define the constant _POSIX_C_SOURCE. All the POSIX.1 headers use this constant to exclude any implementation-defined definitions when _POSIX_C_SOURCE is defined.

The constants _POSIX_C_SOURCE and _XOPEN_SOURCE are called feature test macros. All feature test macros begin with an underscore. When used, they are typically defined in the cc command, as in cc -D_POSIX_C_SOURCE=200809L file.c

### 2.8 Primitive System Data Types

Historically, certain C data types have been associated with certain UNIX system variables.

The header <sys/types.h> defines some implementation-dependent data types, called the primitive system data types.

### 2.9 Differences Between Standards

ISO C defines the function clock to return the amount of CPU time used by a process. The value returned is a clock_t value, but ISO C doesn’t specify its units. To convert this value to seconds, we divide it by CLOCKS_PER_SEC, which is defined in the <time.h> header. POSIX.1 defines the function times that returns both the CPU time (for the caller and all its terminated children) and the clock time. All these time values are clock_t values.

### 2.10 Summary

Much has happened with the standardization of the UNIX programming environment over the past two and a half decades. We’ve described the dominant standards — ISO C, POSIX, and the Single UNIX Specification—and their effect on the four platforms that we’ll examine in this text—FreeBSD, Linux, Mac OS X, and Solaris.

## Chapter 3. File I/O

### 3.1 Introduction

We’ll start our discussion of the UNIX System by describing the functions available for file I/O—open a file, read a file, write a file, and so on. Most file I/O on a UNIX system can be performed using only five functions: open, read, write, lseek, and close. We then examine the effect of various buffer sizes on the read and write functions.

The functions described in this chapter are often referred to as unbuffered I/O, in contrast to the standard I/O routines, which we describe in Chapter 5. The term unbuffered means that each read or write invokes a system call in the kernel. These unbuffered I/O functions are not part of ISO C, but are part of POSIX.1 and the Single UNIX Specification.

Whenever we describe the sharing of resources among multiple processes, the concept of an atomic operation becomes important. We examine this concept with regard to file I/O and the arguments to the open function. This leads to a discussion of how files are shared among multiple processes and which kernel data structures are involved. After describing these features, we describe the dup, fcntl, sync, fsync, and ioctl functions.

### 3.2 File Descr iptors

To the kernel, all open files are referred to by file descriptors. A file descriptor is a non-negative integer. When we open an existing file or create a new file, the kernel returns a file descriptor to the process. When we want to read or write a file, we identify the file with the file descriptor that was returned by open or creat as an argument to either read or write.

By convention, UNIX System shells associate file descriptor 0 with the standard input of a process, file descriptor 1 with the standard output, and file descriptor 2 with the standard error. This convention is used by the shells and many applications; it is not a feature of the UNIX kernel.

### 3.3 open and openat Functions

A file is opened or created by calling either the open function or the openat function.

```c
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */ );
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );
```

The file descriptor returned by open and openat is guaranteed to be the lowestnumbered unused descriptor. This fact is used by some applications to open a new file on standard input, standard output, or standard error.

The fd parameter distinguishes the openat function from the open function. There are three possibilities:

1. The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function.
2. The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated.
3. The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function.

The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. Second, it provides a way to avoid time-of-check-to-time-of-use (TOCTTOU) errors.

The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole.

### 3.4 creat Function

A new file can also be created by calling the creat function.

```c
#include <fcntl.h>
int creat(const char *path, mode_t mode);
// Note that this function is equivalent to 
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
```

### 3.5 close Function

An open file is closed by calling the close function.

```c
#include <unistd.h>
int close(int fd);
```

Closing a file also releases any record locks that the process may have on the file.

When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files.

### 3.6 lseek Function

Every open file has an associated ‘‘current file offset,’’ normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.

An open file’s offset can be set explicitly by calling lseek.

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

The interpretation of the offset depends on the value of the whence argument.

* If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of the file.
* If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. The offset can be positive or negative.
* If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. The offset can be positive or negative.

Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset:

```c
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
```

This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns −1.

lseek only records the current file offset within the kernel—it does not cause any I/O to take place. This offset is then used by the next read or write operation.

The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.

### 3.7 read Function

Data is read from an open file with the read function.

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
// Returns: number of bytes read, 0 if end of file, −1 on error
```

There are several cases in which the number of bytes actually read is less than the amount requested:

* When reading from a regular file, if the end of file is reached before the requested number of bytes has been read. For example, if 30 bytes remain until the end of file and we try to read 100 bytes, read returns 30. The next time we call read, it will return 0 (end of file).
* When reading from a terminal device. Normally, up to one line is read at a time. 
* When reading from a network. Buffering within the network may cause less than the requested amount to be returned.
* When reading from a pipe or FIFO. If the pipe contains fewer bytes than requested, read will return only what is available.
* When reading from a record-oriented device. Some record-oriented devices, such as magnetic tape, can return up to a single record at a time.
* When interrupted by a signal and a partial amount of data has already been read. 

The read operation starts at the file’s current offset. Beforeasuccessful return, the offset is incremented by the number of bytes actually read.
POSIX.1 changed the prototype for this function in several ways. The classic definition is
`int read(int fd, char *buf, unsigned nbytes);`

* First, the second argument was changed from char * to void * to be consistent with ISO C: the type void * is used for generic pointers.
* Next, the return value was required to be a signed integer (ssize_t) to return a positive byte count, 0 (for end of file), or −1 (for an error).
* Finally, the third argument historically has been an unsigned integer, to allow a 16-bit implementation to read or write up to 65,534 bytes at a time. With the 1990 POSIX.1 standard, the primitive system data type ssize_t was introduced to provide the signed return value, and the unsigned size_t was used for the third argument.

### 3.8 write Function

Data is written to an open file with the write function.

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
// Returns: number of bytes written if OK, −1 on error
```

For a regular file, the write operation starts at the file’s current offset. If the O_APPEND option was specified when the file was opened, the file’s offset is set to the current end of file before each write operation. After a successful write, the file’s offset is incremented by the number of bytes actually written.

### 3.9 I/O Efficiency

The following program copies a file, using only the read and write functions.

```c
#include "apue.h"
#define BUFFSIZE 4096
int main(void) {
    int n;
    char buf[BUFFSIZE];
    while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
        if (write(STDOUT_FILENO, buf, n) != n)
            err_sys("write error");
    if (n < 0)
        err_sys("read error");
    exit(0);
}
```

The following caveats apply to this program.

• It reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed. Indeed, all normal UNIX system shells provide a way to open a file for reading on standard input and to create (or rewrite) a file on standard output. This prevents the program from having to open the input and output files, and allows the user to take advantage of the shell’s I/O redirection facilities.
• The program doesn’t close the input file or output file. Instead, the program uses the feature of the UNIX kernel that closes all open file descriptors in a process when that process terminates.
• This example works for both text files and binary files, since there is no difference between the two to the UNIX kernel.

Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly.

### 3.10 File Sharing

The UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O.

The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.

1. Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are

    a. The file descriptor flags 
    b. A pointer to a file table entry
2. The kernel maintains a file table for all open files. Each file table entry contains

    a. The file status flags for the file, such as read, write, append, sync, and nonblocking;
    b. The current file offset
    c. A pointer to the v-node table entry for the file
3. Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on.

### 3.11 Atomic Operations

The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write.

The Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite.

```c
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
// Returns: number of bytes read, 0 if end of file, −1 on error
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
// Returns: number of bytes written if OK, −1 on error
```

Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions.

• There is no way to interrupt the two operations that occur when we call pread.
• The current file offset is not updated.

Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions.

In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed.

### 3.12 dup and dup2 Functions

An existing file descriptor is duplicated by either of the following functions:

```c
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);
// Both return: new file descriptor if OK, −1 on error
```

The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec.

The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument.

### 3.13 sync, fsync, and fdatasync Functions

Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write.

The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided.

```c
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);
// Returns: 0 if OK, −1 on error
void sync(void);
```

The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place. The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function.

The function fsync refers only to a single file, specified by the file descriptor fd, and waits for the disk writes to complete before returning. This function is used when an application, such as a database, needs to be sure that the modified blocks have been written to the disk.

The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously.

### 3.14 fcntl Function

The fcntl function can change the properties of a file that is already open.

```c
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* int arg */ );
// Returns: depends on cmd if OK (see following), −1 on error
```

The fcntl function is used for five different purposes.

1. Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC)
2. Get/set file descriptor flags (cmd = F_GETFD or F_SETFD)
3. Get/set file status flags (cmd = F_GETFL or F_SETFL)
4. Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN)
5. Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW)

 
### 3.15 ioctl Function



### 3.16 /dev/fd



### 3.17 Summary



## Chapter 4. Files and Directories



### 4.1 Introduction



### 4.2 stat, fstat, fstatat, and lstat Functions



### 4.3 File Types



### 4.4 Set-User-ID and Set-Group-ID



### 4.5 File Access Per missions



### 4.6 Ownership of New Files and Directories



### 4.7 access and faccessat Functions



### 4.8 umask Function



### 4.9 chmod, fchmod, and fchmodat Functions



### 4.10 Sticky Bit



### 4.11 chown, fchown, fchownat, and lchown Functions



### 4.12 File Size



### 4.13 File Tr uncation



### 4.14 File Systems



### 4.15 link, linkat, unlink, unlinkat, and remove Functions



### 4.16 rename and renameat Functions



### 4.17 Symbolic Links



### 4.18 Creating and Reading Symbolic Links



### 4.19 File Times



### 4.20 futimens, utimensat, and utimes Functions



### 4.21 mkdir, mkdirat, and rmdir Functions



### 4.22 Reading Director ies



### 4.23 chdir, fchdir, and getcwd Functions



### 4.24 Device Special Files



### 4.25 Summary of File Access Per mission Bits



### 4.26 Summary



## Chapter 5. Standard I/O Library



### 5.1 Introduction



### 5.2 Streams and FILE Objects



### 5.3 Standard Input, Standard Output, and Standard Error



### 5.4 Buffer ing



### 5.5 Opening a Stream



### 5.6 Reading and Writing a Stream



### 5.7 Line-at-a-Time I/O



### 5.8 Standard I/O Efficiency



### 5.9 Binary I/O



### 5.10 Positioning a Stream



### 5.11 For matted I/O



### 5.12 Implementation Details



### 5.13 Temporar y Files



### 5.14 Memory Streams



### 5.15 Alternatives to Standard I/O



### 5.16 Summary



## Chapter 6. System Data Files and Information



### 6.1 Introduction



### 6.2 Password File



### 6.3 Shadow Passwords



### 6.4 Group File



### 6.5 Supplementary Group IDs



### 6.6 Implementation Differences



### 6.7 Other Data Files



### 6.8 Login Accounting



### 6.9 System Identification



### 6.10 Time and Date Routines



### 6.11 Summary



## Chapter 7. Process Environment



### 7.1 Introduction



### 7.2 main Function



### 7.3 Process Termination



### 7.4 Command-Line Arguments



### 7.5 Environment List



### 7.6 Memory Lay out of a C Program



### 7.7 Shared Librar ies



### 7.8 Memory Allocation



### 7.9 Environment Var iables



### 7.10 setjmp and longjmp Functions



### 7.11 getrlimit and setrlimit Functions



### 7.12 Summary



## Chapter 8. Process Control



### 8.1 Introduction



### 8.2 Process Identifiers



### 8.3 fork Function



### 8.4 vfork Function



### 8.5 exit Functions



### 8.6 wait and waitpid Functions



### 8.7 waitid Function



### 8.8 wait3 and wait4 Functions



### 8.9 Race Conditions



### 8.10 exec Functions



### 8.11 Changing User IDs and Group IDs



### 8.12 Interpreter Files



### 8.13 system Function



### 8.14 Process Accounting



### 8.15 User Identification



### 8.16 Process Scheduling



### 8.17 Process Times



### 8.18 Summary



## Chapter 9. Process Relationships



### 9.1 Introduction



### 9.2 Ter minal Logins



### 9.3 Networ k Logins



### 9.4 Process Groups



### 9.5 Sessions



### 9.6 Controlling Terminal



### 9.7 tcgetpgrp, tcsetpgrp, and tcgetsid Functions



### 9.8 Job Control



### 9.9 Shell Execution of Programs



### 9.10 Orphaned Process Groups



### 9.11 FreeBSD Implementation



### 9.12 Summary



## Chapter 10. Signals



### 10.1 Introduction



### 10.2 Signal Concepts



### 10.3 signal Function



### 10.4 Unreliable Signals



### 10.5 Interrupted System Calls



### 10.6 Reentrant Functions



### 10.7 SIGCLD Semantics



### 10.8 Reliable-Signal Ter minology and Semantics



### 10.9 kill and raise Functions



### 10.10 alarm and pause Functions



### 10.11 Signal Sets



### 10.12 sigprocmask Function



### 10.13 sigpending Function



### 10.14 sigaction Function



### 10.15 sigsetjmp and siglongjmp Functions



### 10.16 sigsuspend Function



### 10.17 abort Function



### 10.18 system Function



### 10.19 sleep, nanosleep, and clock_nanosleep Functions



### 10.20 sigqueue Function



### 10.21 Job-Control Signals



### 10.22 Signal Names and Numbers



### 10.23 Summary



## Chapter 11. Threads



### 11.1 Introduction



### 11.2 Thread Concepts



### 11.3 Thread Identification



### 11.4 Thread Creation



### 11.5 Thread Termination



### 11.6 Thread Synchronization



### 11.6.1 Mutexes



### 11.6.2 Deadlock Avoidance



### 11.6.3 pthread_mutex_timedlock Function



### 11.6.4 Reader–Writer Locks



### 11.6.5 Reader–Writer Locking with Timeouts



### 11.6.6 Condition Variables



### 11.6.7 Spin Locks



### 11.6.8 Barriers



### 11.7 Summary



## Chapter 12. Thread Control



### 12.1 Introduction



### 12.2 Thread Limits



### 12.3 Thread Attr ibutes



### 12.4 Synchronization Attr ibutes



### 12.4.1 Mutex Attr ibutes



### 12.4.2 Reader–Writer Lock Attr ibutes



### 12.4.3 Condition Variable Attributes



### 12.4.4 Barrier Attributes



### 12.5 Reentrancy



### 12.6 Thread-Specific Data



### 12.7 Cancel Options



### 12.8 Threads and Signals



### 12.9 Threads and fork



### 12.10 Threads and I/O



### 12.11 Summary



## Chapter 13. Daemon Processes



### 13.1 Introduction



### 13.2 Daemon Character istics



### 13.3 Coding Rules



### 13.4 Error Logging



### 13.5 Single-Instance Daemons



### 13.6 Daemon Conventions



### 13.7 Client–Server Model



### 13.8 Summary



## Chapter 14. Advanced I/O



### 14.1 Introduction



### 14.2 Nonblocking I/O



### 14.3 Record Locking



### 14.4 I/O Multiplexing



### 14.4.1 select and pselect Functions



### 14.4.2 poll Function



### 14.5 Asynchronous I/O



### 14.5.1 System V Asynchronous I/O



### 14.5.2 BSD Asynchronous I/O



### 14.5.3 POSIX Asynchronous I/O



### 14.6 readv and writev Functions



### 14.7 readn and writen Functions



### 14.8 Memory-Mapped I/O



### 14.9 Summary



## Chapter 15. Interprocess Communication



### 15.1 Introduction



### 15.2 Pipes



### 15.3 popen and pclose Functions



### 15.4 Coprocesses



### 15.5 FIFOs



### 15.6 XSI IPC



### 15.6.1 Identifiers and Keys



### 15.6.2 Per mission Str ucture



### 15.6.3 Configuration Limits



### 15.6.4 Advantages and Disadvantages



### 15.7 Message Queues



### 15.8 Semaphores



### 15.9 Shared Memor y



### 15.10 POSIX Semaphores



### 15.11 Client–Server Proper ties



### 15.12 Summary



## Chapter 16. Network IPC: Sockets



### 16.1 Introduction



### 16.2 Socket Descr iptors



### 16.3 Addressing



### 16.3.1 Byte Order ing



### 16.3.2 Address Formats



### 16.3.3 Address Lookup



### 16.3.4 Associating Addresses with Sockets



### 16.4 Connection Establishment



### 16.5 Data Tr ansfer



### 16.6 Socket Options



### 16.7 Out-of-Band Data



### 16.8 Nonblocking and Asynchronous I/O



### 16.9 Summary



## Chapter 17. Advanced IPC



### 17.1 Introduction



### 17.2 UNIX Domain Sockets



### 17.2.1 Naming UNIX Domain Sockets



### 17.3 Unique Connections



### 17.4 Passing File Descriptors



### 17.5 An Open Server, Version 1



### 17.6 An Open Server, Version 2



### 17.7 Summary



## Chapter 18. Terminal I/O



### 18.1 Introduction



### 18.2 Over view



### 18.3 Special Input Characters



### 18.4 Getting and Setting Ter minal Attr ibutes



### 18.5 Ter minal Option Flags



### 18.6 stty Command



### 18.7 Baud Rate Functions



### 18.8 Line Control Functions



### 18.9 Ter minal Identification



### 18.10 Canonical Mode



### 18.11 Noncanonical Mode



### 18.12 Ter minal Window Size



### 18.13 termcap, terminfo, and curses



### 18.14 Summary



## Chapter 19. Pseudo Terminals



### 19.1 Introduction



### 19.2 Over view



### 19.3 Opening Pseudo-Ter minal Devices



### 19.4 pty_fork Function



### 19.5 pty Program



### 19.6 Using the pty Program



### 19.7 Advanced Features



### 19.8 Summary



## Chapter 20. A Database Library



### 20.1 Introduction



### 20.2 History



### 20.3 The Librar y



### 20.4 Implementation Over view



### 20.5 Centralized or Decentralized?



### 20.6 Concurrency



### 20.7 Building the Librar y



### 20.8 Source Code



### 20.9 Perfor mance



### 20.10 Summary



## Chapter 21. Communicating with a Network Printer



### 21.1 Introduction



### 21.2 The Inter net Pr inting Protocol



### 21.3 The Hyper text Transfer Protocol



### 21.4 Printer Spooling



### 21.5 Source Code



### 21.6 Summary
