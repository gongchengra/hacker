# Advanced Programming in the UNIX® Environment

Third Edition

src.3e.tar.gz was downloaded from http://www.apuebook.com/code3e.html
It contains source code for the book Advanced Programming in the UNIX® Environment, Third Edition
tar -zxvf src.3e.tar.gz get apeu direcotry.
In this repository, I renamed the direcotries according to chapters in the book, also formated the c code for learning purpose.

## Contents

Foreword to the Second Edition xix

Preface xxi

Preface to the Second Edition xxv

Preface to the First Edition xxix

Chapter 1. UNIX System Overview 1

1.1 Introduction 1

1.2 UNIX Architecture 1

1.3 Logging In 2

1.4 Files and Directories 4

1.5 Input and Output 8

1.6 Programs and Processes 10

1.7 Error Handling 14

1.8 User Identification 16

1.9 Signals 18

1.10 Time Values 20

1.11 System Calls and Librar y Functions 21

1.12 Summary 23

Chapter 2. UNIX Standardization and Implementations 25

2.1 Introduction 25

2.2 UNIX Standardization 25

2.2.1 ISO C 25

2.2.2 IEEE POSIX 26

2.2.3 The Single UNIX Specification 30

2.2.4 FIPS 32

2.3 UNIX System Implementations 33

2.3.1 UNIX System V Release 4 33

2.3.2 4.4BSD 34

2.3.3 FreeBSD 34

2.3.4 Linux 35

2.3.5 Mac OS X 35

2.3.6 Solaris 35

2.3.7 Other UNIX Systems 35

2.4 Relationship of Standards and Implementations 36

2.5 Limits 36

2.5.1 ISO C Limits 37

2.5.2 POSIX Limits 38

2.5.3 XSI Limits 41

2.5.4 sysconf, pathconf, and fpathconf Functions 42

2.5.5 Indeterminate Runtime Limits 49

2.6 Options 53

2.7 Feature Test Macros 57

2.8 Primitive System Data Types 58

2.9 Differences Between Standards 58

2.10 Summary 60

Chapter 3. File I/O 61

3.1 Introduction 61

3.2 File Descr iptors 61

3.3 open and openat Functions 62

3.4 creat Function 66

3.5 close Function 66

3.6 lseek Function 66

3.7 read Function 71

3.8 write Function 72

3.9 I/O Efficiency 72

3.10 File Sharing 74

3.11 Atomic Operations 77

3.12 dup and dup2 Functions 79

3.13 sync, fsync, and fdatasync Functions 81

3.14 fcntl Function 82

3.15 ioctl Function 87

3.16 /dev/fd 88

3.17 Summary 90

Chapter 4. Files and Directories 93

4.1 Introduction 93

4.2 stat, fstat, fstatat, and lstat Functions 93

4.3 File Types 95

4.4 Set-User-ID and Set-Group-ID 98

4.5 File Access Per missions 99

4.6 Ownership of New Files and Directories 101

4.7 access and faccessat Functions 102

4.8 umask Function 104

4.9 chmod, fchmod, and fchmodat Functions 106

4.10 Sticky Bit 108

4.11 chown, fchown, fchownat, and lchown Functions 109

4.12 File Size 111

4.13 File Tr uncation 112

4.14 File Systems 113

4.15 link, linkat, unlink, unlinkat, and remove Functions 116

4.16 rename and renameat Functions 119

4.17 Symbolic Links 120

4.18 Creating and Reading Symbolic Links 123

4.19 File Times 124

4.20 futimens, utimensat, and utimes Functions 126

4.21 mkdir, mkdirat, and rmdir Functions 129

4.22 Reading Director ies 130

4.23 chdir, fchdir, and getcwd Functions 135

4.24 Device Special Files 137

4.25 Summary of File Access Per mission Bits 140

4.26 Summary 140

Chapter 5. Standard I/O Library 143

5.1 Introduction 143

5.2 Streams and FILE Objects 143

5.3 Standard Input, Standard Output, and Standard Error 145

5.4 Buffer ing 145

5.5 Opening a Stream 148

5.6 Reading and Writing a Stream 150

5.7 Line-at-a-Time I/O 152

5.8 Standard I/O Efficiency 153

5.9 Binary I/O 156

5.10 Positioning a Stream 157

5.11 For matted I/O 159

5.12 Implementation Details 164

5.13 Temporar y Files 167

5.14 Memory Streams 171

5.15 Alternatives to Standard I/O 174

5.16 Summary 175

Chapter 6. System Data Files and Information 177

6.1 Introduction 177

6.2 Password File 177

6.3 Shadow Passwords 181

6.4 Group File 182

6.5 Supplementary Group IDs 183

6.6 Implementation Differences 184

6.7 Other Data Files 185

6.8 Login Accounting 186

6.9 System Identification 187

6.10 Time and Date Routines 189

6.11 Summary 196

Chapter 7. Process Environment 197

7.1 Introduction 197

7.2 main Function 197

7.3 Process Termination 198

7.4 Command-Line Arguments 203

7.5 Environment List 203

7.6 Memory Lay out of a C Program 204

7.7 Shared Librar ies 206

7.8 Memory Allocation 207

7.9 Environment Var iables 210

7.10 setjmp and longjmp Functions 213

7.11 getrlimit and setrlimit Functions 220

7.12 Summary 225

Chapter 8. Process Control 227

8.1 Introduction 227

8.2 Process Identifiers 227

8.3 fork Function 229

8.4 vfork Function 234

8.5 exit Functions 236

8.6 wait and waitpid Functions 238

8.7 waitid Function 244

8.8 wait3 and wait4 Functions 245

8.9 Race Conditions 245

8.10 exec Functions 249

8.11 Changing User IDs and Group IDs 255

8.12 Interpreter Files 260

8.13 system Function 264

8.14 Process Accounting 269

8.15 User Identification 275

8.16 Process Scheduling 276

8.17 Process Times 280

8.18 Summary 282

Chapter 9. Process Relationships 285

9.1 Introduction 285

9.2 Ter minal Logins 285

9.3 Networ k Logins 290

9.4 Process Groups 293

9.5 Sessions 295

9.6 Controlling Terminal 296

9.7 tcgetpgrp, tcsetpgrp, and tcgetsid Functions 298

9.8 Job Control 299

9.9 Shell Execution of Programs 303

9.10 Orphaned Process Groups 307

9.11 FreeBSD Implementation 310

9.12 Summary 312

Chapter 10. Signals 313

10.1 Introduction 313

10.2 Signal Concepts 313

10.3 signal Function 323

10.4 Unreliable Signals 326

10.5 Interrupted System Calls 327

10.6 Reentrant Functions 330

10.7 SIGCLD Semantics 332

10.8 Reliable-Signal Ter minology and Semantics 335

10.9 kill and raise Functions 336

10.10 alarm and pause Functions 338

10.11 Signal Sets 344

10.12 sigprocmask Function 346

10.13 sigpending Function 347

10.14 sigaction Function 349

10.15 sigsetjmp and siglongjmp Functions 355

10.16 sigsuspend Function 359

10.17 abort Function 365

10.18 system Function 367

10.19 sleep, nanosleep, and clock_nanosleep Functions 373

10.20 sigqueue Function 376

10.21 Job-Control Signals 377

10.22 Signal Names and Numbers 379

10.23 Summary 381

Chapter 11. Threads 383

11.1 Introduction 383

11.2 Thread Concepts 383

11.3 Thread Identification 384

11.4 Thread Creation 385

11.5 Thread Termination 388

11.6 Thread Synchronization 397

11.6.1 Mutexes 399

11.6.2 Deadlock Avoidance 402

11.6.3 pthread_mutex_timedlock Function 407

11.6.4 Reader–Writer Locks 409

11.6.5 Reader–Writer Locking with Timeouts 413

11.6.6 Condition Variables 413

11.6.7 Spin Locks 417

11.6.8 Barriers 418

11.7 Summary 422

Chapter 12. Thread Control 425

12.1 Introduction 425

12.2 Thread Limits 425

12.3 Thread Attr ibutes 426

12.4 Synchronization Attr ibutes 430

12.4.1 Mutex Attr ibutes 430

12.4.2 Reader–Writer Lock Attr ibutes 439

12.4.3 Condition Variable Attributes 440

12.4.4 Barrier Attributes 441

12.5 Reentrancy 442

12.6 Thread-Specific Data 446

12.7 Cancel Options 451

12.8 Threads and Signals 453

12.9 Threads and fork 457

12.10 Threads and I/O 461

12.11 Summary 462

Chapter 13. Daemon Processes 463

13.1 Introduction 463

13.2 Daemon Character istics 463

13.3 Coding Rules 466

13.4 Error Logging 469

13.5 Single-Instance Daemons 473

13.6 Daemon Conventions 474

13.7 Client–Server Model 479

13.8 Summary 480

Chapter 14. Advanced I/O 481

14.1 Introduction 481

14.2 Nonblocking I/O 481

14.3 Record Locking 485

14.4 I/O Multiplexing 500

14.4.1 select and pselect Functions 502

14.4.2 poll Function 506

14.5 Asynchronous I/O 509

14.5.1 System V Asynchronous I/O 510

14.5.2 BSD Asynchronous I/O 510

14.5.3 POSIX Asynchronous I/O 511

14.6 readv and writev Functions 521

14.7 readn and writen Functions 523

14.8 Memory-Mapped I/O 525

14.9 Summary 531

Chapter 15. Interprocess Communication 533

15.1 Introduction 533

15.2 Pipes 534

15.3 popen and pclose Functions 541

15.4 Coprocesses 548

15.5 FIFOs 552

15.6 XSI IPC 556

15.6.1 Identifiers and Keys 556

15.6.2 Per mission Str ucture 558

15.6.3 Configuration Limits 559

15.6.4 Advantages and Disadvantages 559

15.7 Message Queues 561

15.8 Semaphores 565

15.9 Shared Memor y 571

15.10 POSIX Semaphores 579

15.11 Client–Server Proper ties 585

15.12 Summary 587

Chapter 16. Network IPC: Sockets 589

16.1 Introduction 589

16.2 Socket Descr iptors 590

16.3 Addressing 593

16.3.1 Byte Order ing 593

16.3.2 Address Formats 595

16.3.3 Address Lookup 597

16.3.4 Associating Addresses with Sockets 604

16.4 Connection Establishment 605

16.5 Data Tr ansfer 610

16.6 Socket Options 623

16.7 Out-of-Band Data 626

16.8 Nonblocking and Asynchronous I/O 627

16.9 Summary 628

Chapter 17. Advanced IPC 629

17.1 Introduction 629

17.2 UNIX Domain Sockets 629

17.2.1 Naming UNIX Domain Sockets 634

17.3 Unique Connections 635

17.4 Passing File Descriptors 642

17.5 An Open Server, Version 1 653

17.6 An Open Server, Version 2 659

17.7 Summary 669

Chapter 18. Terminal I/O 671

18.1 Introduction 671

18.2 Over view 671

18.3 Special Input Characters 678

18.4 Getting and Setting Ter minal Attr ibutes 683

18.5 Ter minal Option Flags 683

18.6 stty Command 691

18.7 Baud Rate Functions 692

18.8 Line Control Functions 693

18.9 Ter minal Identification 694

18.10 Canonical Mode 700

18.11 Noncanonical Mode 703

18.12 Ter minal Window Size 710

18.13 termcap, terminfo, and curses 712

18.14 Summary 713

Chapter 19. Pseudo Terminals 715

19.1 Introduction 715

19.2 Over view 715

19.3 Opening Pseudo-Ter minal Devices 722

19.4 pty_fork Function 726

19.5 pty Program 729

19.6 Using the pty Program 733

19.7 Advanced Features 740

19.8 Summary 741

Chapter 20. A Database Library 743

20.1 Introduction 743

20.2 History 743

20.3 The Librar y 744

20.4 Implementation Over view 746

20.5 Centralized or Decentralized? 750

20.6 Concurrency 752

20.7 Building the Library 753

20.8 Source Code 753

20.9 Perfor mance 781

20.10 Summary 786

Chapter 21. Communicating with a Network Printer 789

21.1 Introduction 789

21.2 The Inter net Pr inting Protocol 789

21.3 The Hyper text Transfer Protocol 792

21.4 Printer Spooling 793

21.5 Source Code 795

21.6 Summary 843

Appendix A. Function Prototypes 845

Appendix B. Miscellaneous Source Code 895

B.1 Our Header File 895

B.2 Standard Error Routines 898

Appendix C. Solutions to Selected Exercises 905

Bibliography 947

Index 955


## Chapter 1. UNIX System Overview

### 1.1 Introduction

This chapter provides a whirlwind tour of the UNIX System from a programmer ’s perspective.

### 1.2 UNIX Architecture

In a strict sense, an operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run. Generally, we call this software the kernel, since it is relatively small and resides at the core of the environment. The interface to the kernel is a layer of software called the system calls.

### 1.3 Logging In

When we log in to a UNIX system, we enter our login name, followed by our password. Once we log in, some system information messages are typically displayed, and then we can type commands to the shell program.

### 1.4 Files and Directories

The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. A directory is a file that contains directory entries. The names in a directory are called filenames. A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname.

Every process has a working directory, sometimes called the current working directory. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the chdir function. When we log in, the working directory is set to our home directory.

### 1.5 Input and Output

File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.

By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error.

Unbuffered I/O is provided by the functions open, read, write, lseek, and close. These functions all work with file descriptors.

The standard I/O functions provide a buffered interface to the unbuffered I/O functions. Using standard I/O relieves us from having to choose optimal buffer sizes, such as the BUFFSIZE constant.

### 1.6 Programs and Processes

A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the seven exec functions.

An executing instance of a program is called a process, a term used on almost every page of this text. The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer.

There are three primary functions for process control: fork, exec, and waitpid.

Usually,aprocess has only one thread of control — one set of machine instructions executing at a time.  Some problems are easier to solve when more than one thread of control can operate on different parts of the problem.

All threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process.

Like processes, threads are identified by IDs. Thread IDs, however, are local to a process. A thread ID from one process has no meaning in another process.

### 1.7 Error Handling

When an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer errno is usually set to a value that tells why.

There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in <errno.h> has a value of 0.

The errors defined in <errno.h> can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user ’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. The typical recovery action for a resource-related nonfatal error is to delay and retry later.

### 1.8 User Identification

The user ID from our entry in the password file is a numeric value that identifies us to the system.

Our entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group.

There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group.

In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups.

### 1.9 Signals

Signals are a technique used to notify a process that some condition has occurred. The process has three choices for dealing with the
signal.

1. Ignore the signal.
2. Let the default action occur.
3. Provide a function that is called when the signal occurs.

### 1.10 Time Values

Historically, UNIX systems have maintained two different time values:
1. Calendar time. This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970, Coordinated Universal Time (UTC).
2. Process time. This is also called CPU time and measures the central processor resources used by a process.

UNIX System maintains three values for a process:

* Clock time
* User CPU time
* System CPU time

The clock time, sometimes called wall clock time, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process.

### 1.11 System Calls and Library Functions

All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls

The technique used on UNIX systems is for each system call to have a function of the same name in the standard C library.

### 1.12 Summary

This chapter has provided a short tour of the UNIX System.

## Chapter 2. UNIX Standardization and Implementations

### 2.1 Introduction

In this chapter we first look at the various standardization efforts that have been under way over the past two and a half decades. We then discuss the effects of these UNIX programming standards on the operating system implementations that are described in this book.

### 2.2 UNIX Standardization

#### 2.2.1 ISO C

In late 1989, ANSI Standard X3.159-1989 for the C programming language was approved. This standard was also adopted as International Standard ISO/IEC 9899:1990. ANSI is the American National Standards Institute, the U.S. member in the International Organization for Standardization (ISO). IEC stands for the International Electrotechnical Commission.

The C standard is now maintained and developed by the ISO/IEC international standardization working group for the C programming language, known as ISO/IEC JTC1/SC22/WG14, or WG14 for short.

In 1999, the ISO C standard was updated and approved as ISO/IEC 9899:1999,
largely to improve support for applications that perform numerical processing. 

The ISO C library can be divided into 24 areas, based on the headers defined by the standard.

#### 2.2.2 IEEE POSIX

POSIX is a family of standards initially developed by the IEEE (Institute of Electrical and Electronics Engineers). POSIX stands for Portable Operating System Interface. It originally referred only to the IEEE Standard 1003.1-1988 — the operating system interface — but was later extended to include many of the standards and draft standards with the 1003 designation, including the shell and utilities (1003.2).

Of specific interest to this book is the 1003.1 operating system interface standard, whose goal is to promote the portability of applications among various UNIX System environments. This standard defines the services that an operating system must provide if it is to be ‘‘POSIX compliant,’’ and has been adopted by most computer vendors.

Because the 1003.1 standard specifies an interface and not an implementation, no distinction is made between system calls and library functions. All the routines in the standard are called functions.

After more than twenty years of work, the standards are mature and stable. The POSIX.1 standard is maintained by an open working group known as the Austin Group (http://www.opengroup.org/austin). To ensure that they are still relevant, the standards need to be either updated or reaffirmed every so often.

#### 2.2.3 The Single UNIX Specification

The Single UNIX Specification, a superset of the POSIX.1 standard, specifies additional interfaces that extend the functionality provided by the POSIX.1 specification. POSIX.1 is equivalent to the Base Specifications portion of the Single UNIX Specification.

The X/Open System Interfaces (XSI) option in POSIX.1 describes optional interfaces and defines which optional portions of POSIX.1 must be supported for an implementation to be deemed XSI conforming. These include file synchronization, thread stack address and size attributes, thread process-shared synchronization, and the _XOPEN_UNIX symbolic constant . Only XSIconforming implementations can be called UNIX systems.

#### 2.2.4 FIPS

FIPS stands for Federal Information Processing Standard. It was published by the U.S. government, which used it for the procurement of computer systems.

### 2.3 UNIX System Implementations

The previous section described ISO C, IEEE POSIX, and the Single UNIX Specification — three standards originally created by independent organizations.

These standards are taken by vendors and turned into actual implementations. In this book, we are interested in both these standards and their implementation.

#### 2.3.1 UNIX System V Release 4

UNIX System V Release 4 (SVR4) was a product of AT&T’s UNIX System Laboratories (USL, formerly AT&T’s UNIX Software Operation). SVR4 merged functionality from AT&T UNIX System V Release 3.2 (SVR3.2), the SunOS operating system from Sun Microsystems, the 4.3BSD release from the University of California, and the Xenix system from Microsoft into one coherent operating system.

#### 2.3.2 4.4BSD

The Berkeley Software Distribution (BSD) releases were produced and distributed by the Computer Systems Research Group (CSRG) at the University of California at Berkeley; 4.2BSD was released in 1983 and 4.3BSD in 1986.  Both of these releases ran on the VAX minicomputer. The next release, 4.3BSD Tahoe in 1988, also ran on a particular minicomputer called the Tahoe.

#### 2.3.3 FreeBSD

FreeBSD is based on the 4.4BSD-Lite operating system. The FreeBSD project was formed to carry on the BSD line after the Computing Science Research Group at the University of California at Berkeley decided to end its work on the BSD versions of the UNIX operating system, and the 386BSD project seemed to be neglected for too long.

#### 2.3.4 Linux

Linux is an operating system that provides a rich programming environment similar to that of a UNIX System; it is freely available under the GNU Public License. The popularity of Linux is somewhat of a phenomenon in the computer industry. Linux is distinguished by often being the first operating system to support new hardware.

Linux was created in 1991 by Linus Torvalds as a replacement for MINIX. A grass-roots effort then sprang up, whereby many developers across the world volunteered their time to use and enhance it.

#### 2.3.5 Mac OS X

Mac OS X is based on entirely different technology than prior versions. The core operating system is called ‘‘Darwin,’’ and is based on a combination of the Mach kernel (Accetta et al. [1986]), the FreeBSD operating system, and an object-oriented framework for drivers and other kernel extensions. As of version 10.5, the Intel port of Mac OS X has been certified to be a UNIX system.

#### 2.3.6 Solaris

Solaris is the version of the UNIX System developed by Sun Microsystems (now Oracle). Solaris is based on System V Release 4, but includes more than fifteen years of enhancements from the engineers at Sun Microsystems. It is arguably the only commercially successful SVR4 descendant, and is formally certified to be a UNIX system.

#### 2.3.7 Other UNIX Systems

Other versions of the UNIX system that have been certified in the past include

* AIX, IBM’s version of the UNIX System
* HP-UX, Hewlett-Packard’s version of the UNIX System
* IRIX, the UNIX System version shipped by Silicon Graphics
* UnixWare, the UNIX System descended from SVR4 sold by SCO

### 2.4 Relationship of Standards and Implementations

The standards that we’ve mentioned define a subset of any actual system. The focus of this book is on four real systems: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris.

Because all four are POSIX compliant to varying degrees, we will also concentrate on the features required by the POSIX.1 standard, noting any differences between POSIX and the actual implementations of these four systems.

Be aware that the implementations provide backward compatibility for features in earlier releases, such as SVR3.2 and 4.3BSD.

### 2.5 Limits

The implementations define many magic numbers and constants. Many of these have been hard coded into programs or were determined using ad hoc techniques. With the various standardization efforts that we’ve described, more portable methods are now provided to determine these magic numbers and implementation-defined limits, greatly improving the portability of software written for the UNIX environment.

Two types of limits are needed:

1. Compile-time limits (e.g., what’s the largest value of a short integer?)
2. Runtime limits (e.g., how many bytes in a filename?)
 
#### 2.5.1 ISO C Limits

All of the compile-time limits defined by ISO C are defined in the file <limits.h>. These constants don’t change in a given system.

#### 2.5.2 POSIX Limits

POSIX.1 defines numerous constants that deal with implementation limits of the operating system. 

Although POSIX.1 defines numerous limits and constants, we’ll concern ourselves with only the ones that affect the base POSIX.1 interfaces. These limits and constants are divided into the following seven categories:

1. Numerical limits: LONG_BIT, SSIZE_MAX, and WORD_BIT
2. Minimum values: the 25 constants in Figure 2.8
3. Maximum value: _POSIX_CLOCKRES_MIN
4. Runtime increasable values: CHARCLASS_NAME_MAX, COLL_WEIGHTS_MAX, LINE_MAX, NGROUPS_MAX, and RE_DUP_MAX
5. Runtime invariant values, possibly indeterminate: 17 constants
6. Other invariant values: NL_ARGMAX, NL_MSGMAX, NL_SETMAX, and NL_TEXTMAX
7. Pathname variable values: FILESIZEBITS, LINK_MAX, MAX_CANON, MAX_INPUT, NAME_MAX, PATH_MAX, PIPE_BUF, and SYMLINK_MAX

These minimum values do not change from one system to another. They specify the most restrictive values for these features. A conforming POSIX.1 implementation must provide values that are at least this large. This is why they are called minimums, although their names all contain MAX.

#### 2.5.3 XSI Limits

The XSI option also defines constants representing implementation limits. They
include:

1. Minimum values: NL_LANGMAX, NZERO, _XOPEN_IOV_MAX, _XOPEN_NAME_MAX, _XOPEN_PATH_MAX
2. Runtime invariant values, possibly indeterminate: IOV_MAX and PAGE_SIZE

#### 2.5.4 sysconf, pathconf, and fpathconf Functions

The runtime limits are obtained by calling one of the following three functions.

```c
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);
```

1. All three functions return −1 and set errno to EINVAL if the name isn’t one of the appropriate constants. The third column in Figures 2.11 and 2.12 lists the limit constants we’ll deal with throughout the rest of this book.
2. Some names can return either the value of the variable (a return value ≥ 0) or an indication that the value is indeterminate. An indeterminate value is indicated by returning −1 and not changing the value of errno.
3. The value returned for _SC_CLK_TCK is the number of clock ticks per second, for use with the return values from the times function. 

Some restrictions apply to the pathconf pathname argument and the fpathconf
fd argument. If any of these restrictions isn’t met, the results are undefined.

1. The referenced file for _PC_MAX_CANON and _PC_MAX_INPUT must be a
terminal file.
2. The referenced file for _PC_LINK_MAX and _PC_TIMESTAMP_RESOLUTION can
be either a file or a directory. If the referenced file is a directory, the return value
applies to the directory itself, not to the filename entries within the directory.
3. The referenced file for _PC_FILESIZEBITS and _PC_NAME_MAX must be a
directory. The return value applies to filenames within the directory
4. The referenced file for _PC_PATH_MAX must be a directory. The value returned is the maximum length of a relative pathname when the specified directory is the working directory.
5. The referenced file for _PC_PIPE_BUF must be a pipe, FIFO, or directory. In the first two cases (pipe or FIFO), the return value is the limit for the referenced pipe or FIFO. For the other case (a directory), the return value is the limit for any FIFO created in that directory
6. The referenced file for _PC_SYMLINK_MAX must be a directory. The value returned is the maximum length of the string that a symbolic link in that directory can contain.

#### 2.5.5 Indeterminate Runtime Limits

We mentioned that some of the limits can be indeterminate. The problem we encounter is that if these limits aren’t defined in the <limits.h> header, we can’t use them at compile time. But they might not be defined at runtime if their value is indeterminate! Let’s look at two specific cases: allocating storage for a pathname and determining the number of file descriptors.

### 2.6 Options

If we are to write portable applications that depend on any of these optionally supported features, we need a portable way to determine whether an implementation supports a given option.  POSIX.1 defines three ways to do this.

1. Compile-time options are defined in <unistd.h>.
2. Runtime options that are not associated with a file or a directory are identified with the sysconf function.
3. Runtime options that are associated with a file or a directory are discovered by calling either the pathconf or the fpathconf function.

For each option, we have three possibilities for a platform’s support status.

1. If the symbolic constant is either undefined or defined to have the value −1, then the corresponding option is unsupported by the platform at compile time. It is possible to run an old application on a newer system where the option is supported, so a runtime check might indicate the option is supported even though the option wasn’t supported at the time the application was compiled.
2. If the symbolic constant is defined to be greater than zero, then the corresponding option is supported.
3. If the symbolic constant is defined to be equal to zero, then we must call sysconf, pathconf, or fpathconf to determine whether the option is supported.

### 2.7 Feature Test Macros

The headers define numerous POSIX.1 and XSI symbols, as we’ve described. Even so, most implementations can add their own definitions to these headers, in addition to the POSIX.1 and XSI definitions. If we want to compile a program so that it depends only on the POSIX definitions and doesn’t conflict with any implementation-defined constants, we need to define the constant _POSIX_C_SOURCE. All the POSIX.1 headers use this constant to exclude any implementation-defined definitions when _POSIX_C_SOURCE is defined.

The constants _POSIX_C_SOURCE and _XOPEN_SOURCE are called feature test macros. All feature test macros begin with an underscore. When used, they are typically defined in the cc command, as in cc -D_POSIX_C_SOURCE=200809L file.c

### 2.8 Primitive System Data Types

Historically, certain C data types have been associated with certain UNIX system variables.

The header <sys/types.h> defines some implementation-dependent data types, called the primitive system data types.

### 2.9 Differences Between Standards

ISO C defines the function clock to return the amount of CPU time used by a process. The value returned is a clock_t value, but ISO C doesn’t specify its units. To convert this value to seconds, we divide it by CLOCKS_PER_SEC, which is defined in the <time.h> header. POSIX.1 defines the function times that returns both the CPU time (for the caller and all its terminated children) and the clock time. All these time values are clock_t values.

### 2.10 Summary

Much has happened with the standardization of the UNIX programming environment over the past two and a half decades. We’ve described the dominant standards — ISO C, POSIX, and the Single UNIX Specification—and their effect on the four platforms that we’ll examine in this text—FreeBSD, Linux, Mac OS X, and Solaris.

## Chapter 3. File I/O

### 3.1 Introduction

We’ll start our discussion of the UNIX System by describing the functions available for file I/O—open a file, read a file, write a file, and so on. Most file I/O on a UNIX system can be performed using only five functions: open, read, write, lseek, and close. We then examine the effect of various buffer sizes on the read and write functions.

The functions described in this chapter are often referred to as unbuffered I/O, in contrast to the standard I/O routines, which we describe in Chapter 5. The term unbuffered means that each read or write invokes a system call in the kernel. These unbuffered I/O functions are not part of ISO C, but are part of POSIX.1 and the Single UNIX Specification.

Whenever we describe the sharing of resources among multiple processes, the concept of an atomic operation becomes important. We examine this concept with regard to file I/O and the arguments to the open function. This leads to a discussion of how files are shared among multiple processes and which kernel data structures are involved. After describing these features, we describe the dup, fcntl, sync, fsync, and ioctl functions.

### 3.2 File Descr iptors

To the kernel, all open files are referred to by file descriptors. A file descriptor is a non-negative integer. When we open an existing file or create a new file, the kernel returns a file descriptor to the process. When we want to read or write a file, we identify the file with the file descriptor that was returned by open or creat as an argument to either read or write.

By convention, UNIX System shells associate file descriptor 0 with the standard input of a process, file descriptor 1 with the standard output, and file descriptor 2 with the standard error. This convention is used by the shells and many applications; it is not a feature of the UNIX kernel.

### 3.3 open and openat Functions

A file is opened or created by calling either the open function or the openat function.

```c
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */ );
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );
```

The file descriptor returned by open and openat is guaranteed to be the lowestnumbered unused descriptor. This fact is used by some applications to open a new file on standard input, standard output, or standard error.

The fd parameter distinguishes the openat function from the open function. There are three possibilities:

1. The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function.
2. The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated.
3. The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function.

The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. Second, it provides a way to avoid time-of-check-to-time-of-use (TOCTTOU) errors.

The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole.

### 3.4 creat Function

A new file can also be created by calling the creat function.

```c
#include <fcntl.h>
int creat(const char *path, mode_t mode);
// Note that this function is equivalent to 
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
```

### 3.5 close Function

An open file is closed by calling the close function.

```c
#include <unistd.h>
int close(int fd);
```

Closing a file also releases any record locks that the process may have on the file.

When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files.

### 3.6 lseek Function

Every open file has an associated ‘‘current file offset,’’ normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.

An open file’s offset can be set explicitly by calling lseek.

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

The interpretation of the offset depends on the value of the whence argument.

* If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of the file.
* If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. The offset can be positive or negative.
* If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. The offset can be positive or negative.

Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset:

```c
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
```

This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns −1.

lseek only records the current file offset within the kernel—it does not cause any I/O to take place. This offset is then used by the next read or write operation.

The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.

### 3.7 read Function

Data is read from an open file with the read function.

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
// Returns: number of bytes read, 0 if end of file, −1 on error
```

There are several cases in which the number of bytes actually read is less than the amount requested:

* When reading from a regular file, if the end of file is reached before the requested number of bytes has been read. For example, if 30 bytes remain until the end of file and we try to read 100 bytes, read returns 30. The next time we call read, it will return 0 (end of file).
* When reading from a terminal device. Normally, up to one line is read at a time. 
* When reading from a network. Buffering within the network may cause less than the requested amount to be returned.
* When reading from a pipe or FIFO. If the pipe contains fewer bytes than requested, read will return only what is available.
* When reading from a record-oriented device. Some record-oriented devices, such as magnetic tape, can return up to a single record at a time.
* When interrupted by a signal and a partial amount of data has already been read. 

The read operation starts at the file’s current offset. Beforeasuccessful return, the offset is incremented by the number of bytes actually read.
POSIX.1 changed the prototype for this function in several ways. The classic definition is
`int read(int fd, char *buf, unsigned nbytes);`

* First, the second argument was changed from char * to void * to be consistent with ISO C: the type void * is used for generic pointers.
* Next, the return value was required to be a signed integer (ssize_t) to return a positive byte count, 0 (for end of file), or −1 (for an error).
* Finally, the third argument historically has been an unsigned integer, to allow a 16-bit implementation to read or write up to 65,534 bytes at a time. With the 1990 POSIX.1 standard, the primitive system data type ssize_t was introduced to provide the signed return value, and the unsigned size_t was used for the third argument.

### 3.8 write Function

Data is written to an open file with the write function.

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
// Returns: number of bytes written if OK, −1 on error
```

For a regular file, the write operation starts at the file’s current offset. If the O_APPEND option was specified when the file was opened, the file’s offset is set to the current end of file before each write operation. After a successful write, the file’s offset is incremented by the number of bytes actually written.

### 3.9 I/O Efficiency

The following program copies a file, using only the read and write functions.

```c
#include "apue.h"
#define BUFFSIZE 4096
int main(void) {
    int n;
    char buf[BUFFSIZE];
    while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
        if (write(STDOUT_FILENO, buf, n) != n)
            err_sys("write error");
    if (n < 0)
        err_sys("read error");
    exit(0);
}
```

The following caveats apply to this program.

• It reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed. Indeed, all normal UNIX system shells provide a way to open a file for reading on standard input and to create (or rewrite) a file on standard output. This prevents the program from having to open the input and output files, and allows the user to take advantage of the shell’s I/O redirection facilities.
• The program doesn’t close the input file or output file. Instead, the program uses the feature of the UNIX kernel that closes all open file descriptors in a process when that process terminates.
• This example works for both text files and binary files, since there is no difference between the two to the UNIX kernel.

Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly.

### 3.10 File Sharing

The UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O.

The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.

1. Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are

    a. The file descriptor flags 
    b. A pointer to a file table entry
2. The kernel maintains a file table for all open files. Each file table entry contains

    a. The file status flags for the file, such as read, write, append, sync, and nonblocking;
    b. The current file offset
    c. A pointer to the v-node table entry for the file
3. Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on.

### 3.11 Atomic Operations

The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write.

The Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite.

```c
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
// Returns: number of bytes read, 0 if end of file, −1 on error
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
// Returns: number of bytes written if OK, −1 on error
```

Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions.

• There is no way to interrupt the two operations that occur when we call pread.
• The current file offset is not updated.

Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions.

In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed.

### 3.12 dup and dup2 Functions

An existing file descriptor is duplicated by either of the following functions:

```c
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);
// Both return: new file descriptor if OK, −1 on error
```

The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec.

The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument.

### 3.13 sync, fsync, and fdatasync Functions

Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write.

The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided.

```c
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);
// Returns: 0 if OK, −1 on error
void sync(void);
```

The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place. The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function.

The function fsync refers only to a single file, specified by the file descriptor fd, and waits for the disk writes to complete before returning. This function is used when an application, such as a database, needs to be sure that the modified blocks have been written to the disk.

The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously.

### 3.14 fcntl Function

The fcntl function can change the properties of a file that is already open.

```c
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* int arg */ );
// Returns: depends on cmd if OK (see following), −1 on error
```

The fcntl function is used for five different purposes.

1. Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC)
2. Get/set file descriptor flags (cmd = F_GETFD or F_SETFD)
3. Get/set file status flags (cmd = F_GETFL or F_SETFL)
4. Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN)
5. Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW)
 
### 3.15 ioctl Function

The ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function.

```c
#include <unistd.h> /* System V */
#include <sys/ioctl.h> /* BSD and Linux */
int ioctl(int fd, int request, ...);
// Returns: −1 on error, something else if OK
```

### 3.16 /dev/fd

Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open.

### 3.17 Summary

This chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance. 

Atomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text.

## Chapter 4. Files and Directories

### 4.1 Introduction

We’ll now look at additional features of the file system and the properties of a file. We’ll start with the stat functions and go through each member of the stat structure, looking at all the attributes of a file. In this process, we’ll also describe each of the functions that modify these attributes: change the owner, change the permissions, and so on. We’ll also look in more detail at the structure of a UNIX file system and symbolic links. We finish this chapter with the functions that operate on directories, and we develop a function that descends through a directory hierarchy.

### 4.2 stat, fstat, fstatat, and lstat Functions

The discussion in this chapter centers on the four stat functions and the information they return.

```c
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf );
int fstat(int fd, struct stat *buf );
int lstat(const char *restrict pathname, struct stat *restrict buf );
int fstatat(int fd, const char *restrict pathname,
struct stat *restrict buf, int flag);
// All four return: 0 if OK, −1 on error
```

### 4.3 File Types

Given a pathname, the stat function returns a structure of information about the named file. The fstat function obtains information about the file that is already open on the descriptor fd. The lstat function is similar to stat, but when the named file is a symbolic link, lstat returns information about the symbolic link, not the file referenced by the symbolic link.

The fstatat function provides a way to return the file statistics for a pathname relative to an open directory represented by the fd argument. The flag argument controls whether symbolic links are followed; when the AT_SYMLINK_NOFOLLOW flag is set, fstatat will not follow symbolic links, but rather returns information about the link itself. Otherwise, the default is to follow symbolic links, returning information about the file to which the symbolic link points. If the fd argument has the value AT_FDCWD and the pathname argument is a relative pathname, then fstatat evaluates the pathname argument relative to the current directory. If the pathname argument is an absolute pathname, then the fd argument is ignored. In these two cases, fstatat behaves like either stat or lstat, depending on the value of flag.

File types:

1. Regular file. The most common type of file, which contains data of some form. There is no distinction to the UNIX kernel whether this data is text or binary. Any interpretation of the contents of a regular file is left to the application processing the file.
2. Directory file. A file that contains the names of other files and pointers to information on these files. Any process that has read permission for a directory file can read the contents of the directory, but only the kernel can write directly to a directory file. Processes must use the functions described in this chapter to make changes to a directory.
3. Block special file. A type of file providing buffered I/O access in fixed-size units to devices such as disk drives.
4. Character special file. A type of file providing unbuffered I/O access in variable-sized units to devices. All devices on a system are either block special files or character special files.
5. FIFO. A type of file used for communication between processes. It’s sometimes called a named pipe.
6. Socket. A type of file used for network communication between processes. A socket can also be used for non-network communication between processes on a single host.
7. Symbolic link. A type of file that points to another file.

### 4.4 Set-User-ID and Set-Group-ID

Every process has six or more IDs associated with it.
who we really are: 
real user ID
real group ID 
used for file access permission checks:
effective user ID
effective group ID 
supplementary group IDs
saved by exec functions:
saved set-user-ID
saved set-group-ID 

* The real user ID and real group ID identify who we really are. These two fields are taken from our entry in the password file when we log in.
* The effective user ID, effective group ID, and supplementary group IDs determine our file access permissions.
* The saved set-user-ID and saved set-group-ID contain copies of the effective user ID and the effective group ID, respectively, when a program is executed.

Normally, the effective user ID equals the real user ID, and the effective group ID equals the real group ID.

Every file has an owner and a group owner. The owner is specified by the st_uid member of the stat structure; the group owner, by the st_gid member.

When we execute a program file, the effective user ID of the process is usually the real user ID, and the effective group ID is usually the real group ID. However, we can also set a special flag in the file’s mode word (st_mode) that says, ‘‘When this file is executed, set the effective user ID of the process to be the owner of the file (st_uid).’’ Similarly, we can set another bit in the file’s mode word that causes the effective group ID to be the group owner of the file (st_gid). These two bits in the file’s mode word are called the set-user-ID bit and the set-group-ID bit.

Returning to the stat function, the set-user-ID bit and the set-group-ID bit are contained in the file’s st_mode value. These two bits can be tested against the constants S_ISUID and S_ISGID, respectively

### 4.5 File Access Per missions

The st_mode value also encodes the access permission bits for the file. When we say file, we mean any of the file types that we described earlier. All the file types — directories, character special files, and so on—have permissions. Many people think of only regular files as having access permissions.

There are nine permission bits for each file, divided into three categories.

st_mode mask Meaning
S_IRUSR user-read
S_IWUSR user-write
S_IXUSR user-execute
S_IRGRP group-read
S_IWGRP group-write
S_IXGRP group-execute
S_IROTH other-read
S_IWOTH other-write
S_IXOTH other-execute

The three categories, read, write, and execute are used in various ways by different functions. We’ll summarize them here, and return to them when we describe the actual functions.

* The first rule is that whenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including the current directory, if it is implied. This is why the execute permission bit for a directory is often called the search bit.
* The read permission for a file determines whether we can open an existing file for reading: the O_RDONLY and O_RDWR flags for the open function.
* The write permission for a file determines whether we can open an existing file for writing: the O_WRONLY and O_RDWR flags for the open function.
*  We must have write permission for a file to specify the O_TRUNC flag in the open function.
*  We cannot create a new file in a directory unless we have write permission and execute permission in the directory.
*  To delete an existing file, we need write permission and execute permission in the directory containing the file. We do not need read permission or write permission for the file itself.
*  Execute permission for a file must be on if we want to execute the file using any of the seven exec functions. The file also has to be a regular file.

The file access tests that the kernel performs each time a process opens, creates, or deletes a file depend on the owners of the file (st_uid and st_gid), the effective IDs of the process (effective user ID and effective group ID), and the supplementary group IDs of the process, if supported. The two owner IDs are properties of the file, whereas the two effective IDs and the supplementary group IDs are properties of the process. The tests performed by the kernel are as follows:

1. If the effective user ID of the process is 0 (the superuser), access is allowed. This gives the superuser free rein throughout the entire file system.
2. If the effective user ID of the process equals the owner ID of the file (i.e., the process owns the file), access is allowed if the appropriate user access permission bit is set. Otherwise, permission is denied. By appropriate access permission bit, we mean that if the process is opening the file for reading, the user-read bit must be on. If the process is opening the file for writing, the user-write bit must be on. If the process is executing the file, the user-execute bit must be on.
3. If the effective group ID of the process or one of the supplementary group IDs of the process equals the group ID of the file, access is allowed if the appropriate group access permission bit is set. Otherwise, permission is denied.
4. If the appropriate other access permission bit is set, access is allowed. Otherwise, permission is denied.

### 4.6 Ownership of New Files and Directories

The user ID of a new file is set to the effective user ID of the process. POSIX.1 allows an implementation to choose one of the following options to determine the group ID of a new file:

1. The group ID of a new file can be the effective group ID of the process.
2. The group ID of a new file can be the group ID of the directory in which the file is being created.

Using the second option—inheriting the directory’s group ID—assures us that all files and directories created in that directory will have the same group ID as the directory. This group ownership of files and directories will then propagate down the hierarchy from that point.

### 4.7 access and faccessat Functions

As we described earlier, when we open a file, the kernel performs its access tests based on the effective user and group IDs. Sometimes, however, a process wants to test accessibility based on the real user and group IDs. This is useful when a process is running as someone else, using either the set-user-ID or the set-group-ID feature. Even though a process might be set-user-ID to root, it might still want to verify that the real user can access a given file. The access and faccessat functions base their tests on the real user and group IDs.

```c
#include <unistd.h>
int access(const char *pathname, int mode);
int faccessat(int fd, const char *pathname, int mode, int flag);
// Both return: 0 if OK, −1 on error
```

The mode is either the value F_OK to test if a file exists, or the bitwise OR of the following flags:

mode Description
R_OK test for read permission
W_OK test for write permission
X_OK test for execute permission

The faccessat function behaves like access when the pathname argument is absolute or when the fd argument has the value AT_FDCWD and the pathname argument is relative. Otherwise, faccessat evaluates the pathname relative to the open directory referenced by the fd argument.

The flag argument can be used to change the behavior of faccessat. If the AT_EACCESS flag is set, the access checks are made using the effective user and group IDs of the calling process instead of the real user and group IDs.

### 4.8 umask Function

The umask function sets the file mode creation mask for the process and returns the previous value. (This is one of the few functions that doesn’t have an error return.)

```c
#include <sys/stat.h>
mode_t umask(mode_t cmask);
// Returns: previous file mode creation mask
```

Most users of UNIX systems never deal with their umask value. It is usually set once, on login, by the shell’s start-up file, and never changed. Nevertheless, when writing programs that create new files, if we want to ensure that specific access permission bits are enabled, we must modify the umask value while the process is running. For example, if we want to ensure that anyone can read a file, we should set the umask to 0. Otherwise, the umask value that is in effect when our process is running can cause permission bits to be turned off.

Users can set the umask value to control the default permissions on the files they create. This value is expressed in octal, with one bit representing one permission to be masked off. Permissions can be denied by setting the corresponding bits. Some common umask values are 002 to prevent others from writing your files, 022 to prevent group members and others from writing your files, and 027 to prevent group members from writing your files and others from reading, writing, or executing your files.

Mask bit Meaning
0400 user-read
0200 user-write
0100 user-execute
0040 group-read
0020 group-write
0010 group-execute
0004 other-read
0002 other-write
0001 other-execute

The Single UNIX Specification requires that the umask command support a symbolic mode of operation. Unlike the octal format, the symbolic format specifies which permissions are to be allowed (i.e., clear in the file creation mask) instead of which ones are to be denied (i.e., set in the file creation mask). Compare both forms of the command, shown below.

### 4.9 chmod, fchmod, and fchmodat Functions

The chmod, fchmod, and fchmodat functions allow us to change the file access permissions for an existing file.

```c
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
int fchmodat(int fd, const char *pathname, mode_t mode, int flag);
// All three return: 0 if OK, −1 on error
```

The chmod function operates on the specified file, whereas the fchmod function operates on a file that has already been opened. The fchmodat function behaves like chmod when the pathname argument is absolute or when the fd argument has the value AT_FDCWD and the pathname argument is relative. Otherwise, fchmodat evaluates the pathname relative to the open directory referenced by the fd argument. The flag argument can be used to change the behavior of fchmodat—when the AT_SYMLINK_NOFOLLOW flag is set, fchmodat doesn’t follow symbolic links.

To change the permission bits of a file, the effective user ID of the process must be equal to the owner ID of the file, or the process must have superuser permissions. The mode is specified as the bitwise OR of the constants shown as follows:

mode Description
S_ISUID set-user-ID on execution
S_ISGID set-group-ID on execution
S_ISVTX saved-text (sticky bit)
S_IRWXU read, write, and execute by user (owner)
S_IRUSR read by user (owner)
S_IWUSR write by user (owner)
S_IXUSR execute by user (owner)
S_IRWXG read, write, and execute by group
S_IRGRP read by group
S_IWGRP write by group
S_IXGRP execute by group
S_IRWXO read, write, and execute by other (world)
S_IROTH read by other (world)
S_IWOTH write by other (world)
S_IXOTH execute by other (world)

The chmod functions automatically clear two of the permission bits under the following conditions:

*  On systems, such as Solaris, that place special meaning on the sticky bit when used with regular files, if we try to set the sticky bit (S_ISVTX) on a regular file and do not have superuser privileges, the sticky bit in the mode is automatically turned off. (We describe the sticky bit in the next section.) To prevent malicious users from setting the sticky bit and adversely affecting system performance, only the superuser can set the sticky bit of a regular file.
*  The group ID of a newly created file might potentially be a group that the calling process does not belong to. It’s possible for the group ID of the new file to be the group ID of the parent directory. Specifically, if the group ID of the new file does not equal either the effective group ID of the process or one of the process’s supplementary group IDs and if the process does not have superuser privileges, then the set-group-ID bit is automatically turned off. This prevents a user from creating a set-group-ID file owned by a group that the user doesn’t belong to.

### 4.10 Sticky Bit

The S_ISVTX bit has an interesting history. On versions of the UNIX System that predated demand paging, this bit was known as the sticky bit. If it was set for an executable program file, then the first time the program was executed, a copy of the program’s text was saved in the swap area when the process terminated.

### 4.11 chown, fchown, fchownat, and lchown Functions

The chown functions allow us to change a file’s user ID and group ID, but if either of the arguments owner or group is −1, the corresponding ID is left unchanged.

```c
#include <unistd.h>
int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int fchownat(int fd, const char *pathname, uid_t owner, gid_t group,
int flag);
int lchown(const char *pathname, uid_t owner, gid_t group);
// All four return: 0 if OK, −1 on error
```

These four functions operate similarly unless the referenced file is a symbolic link. In that case, lchown and fchownat (with the AT_SYMLINK_NOFOLLOW flag set) change the owners of the symbolic link itself, not the file pointed to by the symbolic link.

The fchown function changes the ownership of the open file referenced by the fd argument. Since it operates on a file that is already open, it can’t be used to change the ownership of a symbolic link.

The fchownat function behaves like either chown or lchown when the pathname argument is absolute or when the fd argument has the value AT_FDCWD and the pathname argument is relative. In these cases, fchownat acts like lchown if the AT_SYMLINK_NOFOLLOW flag is set in the flag argument, or it acts like chown if the AT_SYMLINK_NOFOLLOW flag is clear. When the fd argument is set to the file descriptor of an open directory and the pathname argument is a relative pathname, fchownat evaluates the pathname relative to the open directory.

If _POSIX_CHOWN_RESTRICTED is in effect for the specified file, then

1. Only a superuser process can change the user ID of the file.
2. A nonsuperuser process can change the group ID of the file if the process owns the file (the effective user ID equals the user ID of the file), owner is specified as −1 or equals the user ID of the file, and group equals either the effective group ID of the process or one of the process’s supplementary group IDs.

This means that when _POSIX_CHOWN_RESTRICTED is in effect, you can’t change the user ID of your files. You can change the group ID of files that you own, but only to groups that you belong to.

### 4.12 File Size

The st_size member of the stat structure contains the size of the file in bytes. This field is meaningful only for regular files, directories, and symbolic links.

For a regular file, a file size of 0 is allowed. We’ll get an end-of-file indication on the first read of the file. For a directory, the file size is usually a multiple of a number, such as 16 or 512.

For a symbolic link, the file size is the number of bytes in the filename. For example, in the following case, the file size of 7 is the length of the pathname usr/lib:

`lrwxrwxrwx 1 root 7 Sep 25 07:14 lib -> usr/lib`

(Note that symbolic links do not contain the normal C null byte at the end of the name, as the length is always specified by st_size.)

Most contemporary UNIX systems provide the fields st_blksize and st_blocks. The first is the preferred block size for I/O for the file, and the latter is the actual number of 512-byte blocks that are allocated. The standard I/O library, also tries to read or write st_blksize bytes at a time, for efficiency.

### 4.13 File Tr uncation

Sometimes we would like to truncate a file by chopping off data at the end of the file. Emptying a file, which we can do with the O_TRUNC flag to open, is a special case of truncation.

```c
#include <unistd.h>
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);
// Both return: 0 if OK, −1 on error
```

These two functions truncate an existing file to length bytes. If the previous size of the file was greater than length, the data beyond length is no longer accessible. Otherwise, if the previous size was less than length, the file size will increase and the data between the old end of file and the new end of file will read as 0 (i.e., a hole is probably created in the file).

### 4.14 File Systems

To appreciate the concept of links to a file, we need a conceptual understanding of the structure of the UNIX file system. Understanding the difference between an i-node and a directory entry that points to an i-node is also useful. Various implementations of the UNIX file system are in use today. Solaris, for example, supports several types of disk file systems: the traditional BSD-derived UNIX file system (called UFS), a file system (called PCFS) to read and write DOS-formatted diskettes, and a file system (called HSFS) to read CD file systems. UFS is based on the Berkeley fast file system, which we describe in this section.

* Two directory entries point to the same i-node entry. Every i-node has a link count that contains the number of directory entries that point to it. Only when the link count goes to 0 can the file be deleted (thereby releasing the data blocks associated with the file). This is why the operation of ‘‘unlinking a file’’ does not always mean ‘‘deleting the blocks associated with the file.’’ This is why the function that removes a directory entry is called unlink, not delete. In the stat structure, the link count is contained in the st_nlink member. Its primitive system data type is nlink_t. These types of links are called hard links.
* The other type of link is called a symbolic link. With a symbolic link, the actual contents of the file—the data blocks—store the name of the file that the symbolic link points to. In the following example, the filename in the directory entry is the three-character string lib and the 7 bytes of data in the file are usr/lib: `lrwxrwxrwx 1 root 7 Sep 25 07:14 lib -> usr/lib`
* The i-node contains all the information about the file: the file type, the file’s access permission bits, the size of the file, pointers to the file’s data blocks, and so on. Most of the information in the stat structure is obtained from the i-node. Only two items of interest are stored in the directory entry: the filename and the i-node number. The other items—the length of the filename and the length of the directory record—are not of interest to this discussion. The data type for the i-node number is ino_t.
* Because the i-node number in the directory entry points to an i-node in the same file system, a directory entry can’t refer to an i-node in a different file system. This is why the ln(1) command (make a new directory entry that points to an existing file) can’t cross file systems. We describe the link function in the next section.
* When renaming a file without changing file systems, the actual contents of the file need not be moved—all that needs to be done is to add a new directory entry that points to the existing i-node and then unlink the old directory entry. The link count will remain the same. For example, to rename the file /usr/lib/foo to /usr/foo, the contents of the file foo need not be moved if the directories /usr/lib and /usr are on the same file system. This is how the mv(1) command usually operates.

### 4.15 link, linkat, unlink, unlinkat, and remove Functions

We can use either the link function or the linkat function to create a link to an existing file.

```c
#include <unistd.h>
int link(const char *existingpath, const char *newpath);
int linkat(int efd, const char *existingpath, int nfd, const char *newpath,
int flag);
// Both return: 0 if OK, −1 on error
```

These functions create a new directory entry, newpath, that references the existing file existingpath. If the newpath already exists, an error is returned. Only the last component of the newpath is created. The rest of the path must already exist.

With the linkat function, the existing file is specified by both the efd and existingpath arguments, and the new pathname is specified by both the nfd and newpath arguments. By default, if either pathname is relative, it is evaluated relative to the corresponding file descriptor. If either file descriptor is set to AT_FDCWD, then the corresponding pathname, if it is a relative pathname, is evaluated relative to the current directory. If either pathname is absolute, then the corresponding file descriptor argument is ignored.

When the existing file is a symbolic link, the flag argument controls whether the linkat function creates a link to the symbolic link or to the file to which the symbolic link points. If the AT_SYMLINK_FOLLOW flag is set in the flag argument, then a link is created to the target of the symbolic link. If this flag is clear, then a link is created to the symbolic link itself.

The creation of the new directory entry and the increment of the link count must be an atomic operation.

Most implementations require that both pathnames be on the same file system, although POSIX.1 allows an implementation to support linking across file systems. If an implementation supports the creation of hard links to directories, it is restricted to only the superuser. This constraint exists because such hard links can cause loops in the file system, which most utilities that process the file system aren’t capable of handling. Many file system implementations disallow hard links to directories for this reason.

To remove an existing directory entry, we call the unlink function.

```c
#include <unistd.h>
int unlink(const char *pathname);
int unlinkat(int fd, const char *pathname, int flag);
// Both return: 0 if OK, −1 on error
```

These functions remove the directory entry and decrement the link count of the file referenced by pathname. If there are other links to the file, the data in the file is still accessible through the other links. The file is not changed if an error occurs.

As mentioned earlier, to unlink a file, we must have write permission and execute permission in the directory containing the directory entry, as it is the directory entry that we will be removing. Also, as mentioned in Section 4.10, if the sticky bit is set in this directory we must have write permission for the directory and meet one of the following criteria:

*  Own the file
*  Own the directory
*  Have superuser privileges

Only when the link count reaches 0 can the contents of the file be deleted. One other condition prevents the contents of a file from being deleted: as long as some process has the file open, its contents will not be deleted. When a file is closed, the kernel first checks the count of the number of processes that have the file open. If this count has reached 0, the kernel then checks the link count; if it is 0, the file’s contents are deleted.

If the pathname argument is a relative pathname, then the unlinkat function evaluates the pathname relative to the directory represented by the fd file descriptor argument. If the fd argument is set to the value AT_FDCWD, then the pathname is evaluated relative to the current working directory of the calling process. If the pathname argument is an absolute pathname, then the fd argument is ignored.

The flag argument gives callers a way to change the default behavior of the unlinkat function. When the AT_REMOVEDIR flag is set, then the unlinkat function can be used to remove a directory, similar to using rmdir. If this flag is clear, then unlinkat operates like unlink.

### 4.16 rename and renameat Functions

A file or a directory is renamed with either the rename or renameat function.

```c
#include <stdio.h>
int rename(const char *oldname, const char *newname);
int renameat(int oldfd, const char *oldname, int newfd, const char *newname);
// Both return: 0 if OK, −1 on error
```

There are several conditions to describe for these functions, depending on whether oldname refers to a file, a directory, or a symbolic link. We must also describe what happens if newname already exists.

1. If oldname specifies a file that is not a directory, then we are renaming a file or a symbolic link. In this case, if newname exists, it cannot refer to a directory. If newname exists and is not a directory, it is removed, and oldname is renamed to newname. We must have write permission for the directory containing oldname and the directory containing newname, since we are changing both directories.
2. If oldname specifies a directory, then we are renaming a directory. If newname exists, it must refer to a directory, and that directory must be empty. (When we say that a directory is empty, we mean that the only entries in the directory are dot and dot-dot.) If newname exists and is an empty directory, it is removed, and oldname is renamed to newname. Additionally, when we’re renaming a directory, newname cannot contain a path prefix that names oldname. For example, we can’t rename /usr/foo to /usr/foo/testdir, because the old name (/usr/foo) is a path prefix of the new name and cannot be removed.
3. If either oldname or newname refers to a symbolic link, then the link itself is processed, not the file to which it resolves.
4. We can’t rename dot or dot-dot. More precisely, neither dot nor dot-dot can appear as the last component of oldname or newname.
5. As a special case, if oldname and newname refer to the same file, the function returns successfully without changing anything.

If newname already exists, we need permissions as if we were deleting it. Also, because we’re removing the directory entry for oldname and possibly creating a directory entry for newname, we need write permission and execute permission in the directory containing oldname and in the directory containing newname.

The renameat function provides the same functionality as the rename function, except when either oldname or newname refers to a relative pathname. If oldname specifies a relative pathname, it is evaluated relative to the directory referenced by oldfd. Similarly, newname is evaluated relative to the directory referenced by newfd if newname specifies a relative pathname. Either the oldfd or newfd arguments (or both) can be set to AT_FDCWD to evaluate the corresponding pathname relative to the current directory.

### 4.17 Symbolic Links

A symbolic link is an indirect pointer to a file, unlike the hard links described in the previous section, which pointed directly to the i-node of the file. Symbolic links were introduced to get around the limitations of hard links.

* Hard links normally require that the link and the file reside in the same file system.
* Only the superuser can create a hard link to a directory (when supported by the underlying file system).

There are no file system limitations on a symbolic link and what it points to, and anyone can create a symbolic link to a directory. Symbolic links are typically used to ‘‘move’’ a file or an entire directory hierarchy to another location on a system.

When using functions that refer to a file by name, we always need to know whether the function follows a symbolic link. If the function follows a symbolic link, a pathname argument to the function refers to the file pointed to by the symbolic link. Otherwise, a pathname argument refers to the link itself, not the file pointed to by the link.

### 4.18 Creating and Reading Symbolic Links

A symbolic link is created with either the symlink or symlinkat function.

```c
#include <unistd.h>
int symlink(const char *actualpath, const char *sympath);
int symlinkat(const char *actualpath, int fd, const char *sympath);
// Both return: 0 if OK, −1 on error
```

A new directory entry, sympath, is created that points to actualpath. It is not required that actualpath exist when the symbolic link is created. (We saw this in the example at the end of the previous section.) Also, actualpath and sympath need not reside in the same file system.

The symlinkat function is similar to symlink, but the sympath argument is evaluated relative to the directory referenced by the open file descriptor for that directory (specified by the fd argument). If the sympath argument specifies an absolute pathname or if the fd argument has the special value AT_FDCWD, then symlinkat behaves the same way as symlink.

Because the open function follows a symbolic link, we need a way to open the link itself and read the name in the link. The readlink and readlinkat functions do this.

```c
#include <unistd.h>
ssize_t readlink(const char* restrict pathname, char *restrict buf, size_t bufsize);
ssize_t readlinkat(int fd, const char* restrict pathname, char *restrict buf, size_t bufsize);
// Both return: number of bytes read if OK, −1 on error
```

These functions combine the actions of open, read, and close. If successful, they return the number of bytes placed into buf. The contents of the symbolic link that are returned in buf are not null terminated.

The readlinkat function behaves the same way as the readlink function when the pathname argument specifies an absolute pathname or when the fd argument has the special value AT_FDCWD. However, when the fd argument is a valid file descriptor of an open directory and the pathname argument is a relative pathname, then readlinkat evaluates the pathname relative to the open directory represented by fd.

### 4.19 File Times

The actual resolution stored with each file’s attributes depends on the file system implementation. For file systems that store timestamps in second granularity, the nanoseconds fields will be filled with zeros. For file systems that store timestamps in a resolution higher than seconds, the partial seconds value will be converted into nanoseconds and returned in the nanoseconds fields.

Three time fields are maintained for each file.

Field Description Example ls(1) option
st_atim last-access time of file data read -u
st_mtim last-modification time of file data write default
st_ctim last-change time of i-node status chmod, chown -c

The modification time indicates when the contents of the file were last modified. The changed-status time indicates when the i-node of the file was last modified. In this chapter, we’ve described many operations that affect the i-node without changing the actual contents of the file: changing the file access permissions, changing the user ID, changing the number of links, and so on. Because all the information in the i-node is stored separately from the actual contents of the file, we need the changed-status time, in addition to the modification time.

The access time is often used by system administrators to delete files that have not been accessed for a certain amount of time. The classic example is the removal of files named a.out or core that haven’t been accessed in the past week. The find(1) command is often used for this type of operation.

The modification time and the changed-status time can be used to archive only those files that have had their contents modified or their i-node modified.

The ls command displays or sorts only on one of the three time values. By default, when invoked with either the -l or the -t option, it uses the modification time of a file. The -u option causes the ls command to use the access time, and the -c option causes it to use the changed-status time.

### 4.20 futimens, utimensat, and utimes Functions

Several functions are available to change the access time and the modification time of a file. The futimens and utimensat functions provide nanosecond granularity for specifying timestamps, using the timespec structure.

```c
#include <sys/stat.h>
int futimens(int fd, const struct timespec times[2]);
int utimensat(int fd, const char *path, const struct timespec times[2], int flag);
// Both return: 0 if OK, −1 on error
```

In both functions, the first element of the times array argument contains the access time, and the second element contains the modification time. The two time values are calendar times, which count seconds since the Epoch. Partial seconds are expressed in nanoseconds.

Timestamps can be specified in one of four ways:

1. The times argument is a null pointer. In this case, both timestamps are set to the current time.
2. The times argument points to an array of two timespec structures. If either tv_nsec field has the special value UTIME_NOW, the corresponding timestamp is set to the current time. The corresponding tv_sec field is ignored.
3. The times argument points to an array of two timespec structures. If either tv_nsec field has the special value UTIME_OMIT, then the corresponding timestamp is unchanged. The corresponding tv_sec field is ignored.
4. The times argument points to an array of two timespec structures and the tv_nsec field contains a value other than UTIME_NOW or UTIME_OMIT. In this case, the corresponding timestamp is set to the value specified by the corresponding tv_sec and tv_nsec fields.

The privileges required to execute these functions depend on the value of the times argument.

* If times is a null pointer or if either tv_nsec field is set to UTIME_NOW, either the effective user ID of the process must equal the owner ID of the file, the process must have write permission for the file, or the process must be a superuser process.
*  If times is a non-null pointer and either tv_nsec field has a value other than UTIME_NOW or UTIME_OMIT, the effective user ID of the process must equal the owner ID of the file, or the process must be a superuser process. Merely having write permission for the file is not adequate.
*   If times is a non-null pointer and both tv_nsec fields are set to UTIME_OMIT, no permissions checks are performed.

With futimens, you need to open the file to change its times. The utimensat function provides a way to change a file’s times using the file’s name. The pathname argument is evaluated relative to the fd argument, which is either a file descriptor of an open directory or the special value AT_FDCWD to force evaluation relative to the current directory of the calling process. If pathname specifies an absolute pathname, then the fd argument is ignored.

The flag argument to utimensat can be used to further modify the default behavior. If the AT_SYMLINK_NOFOLLOW flag is set, then the times of the symbolic link itself are changed (if the pathname refers to a symbolic link). The default behavior is to follow a symbolic link and modify the times of the file to which the link refers.

Both futimens and utimensat are included in POSIX.1. A third function, utimes, is included in the Single UNIX Specification as part of the XSI option.

```c
#include <sys/time.h>
int utimes(const char *pathname, const struct timeval times[2]);
// Returns: 0 if OK, −1 on error
```

The utimes function operates on a pathname. The times argument is a pointer to an array of two timestamps—access time and modification time—but they are expressed in seconds and microseconds:

```c
struct timeval {
    time_t tv_sec; /* seconds */
    long tv_usec; /* microseconds */
};
```

### 4.21 mkdir, mkdirat, and rmdir Functions

Directories are created with the mkdir and mkdirat functions, and deleted with the rmdir function.

```c
#include <sys/stat.h>
int mkdir(const char *pathname, mode_t mode);
int mkdirat(int fd, const char *pathname, mode_t mode);
//Both return: 0 if OK, −1 on error
```

These functions create a new, empty directory. The entries for dot and dot-dot are created automatically. The specified file access permissions, mode, are modified by the file mode creation mask of the process.

A common mistake is to specify the same mode as for a file: read and write permissions only. But for a directory, we normally want at least one of the execute bits enabled, to allow access to filenames within the directory.

The mkdirat function is similar to the mkdir function. When the fd argument has the special value AT_FDCWD, or when the pathname argument specifies an absolute pathname, mkdirat behaves exactly like mkdir. Otherwise, the fd argument is an open directory from which relative pathnames will be evaluated.

An empty directory is deleted with the rmdir function. Recall that an empty directory is one that contains entries only for dot and dot-dot.

```c
#include <unistd.h>
int rmdir(const char *pathname);
// Returns: 0 if OK, −1 on error
```

If the link count of the directory becomes 0 with this call, and if no other process has the directory open, then the space occupied by the directory is freed. If one or more processes have the directory open when the link count reaches 0, the last link is removed and the dot and dot-dot entries are removed before this function returns. Additionally, no new files can be created in the directory. The directory is not freed, however, until the last process closes it. (Even though some other process has the directory open, it can’t be doing much in the directory, as the directory had to be empty for the rmdir function to succeed.)

### 4.22 Reading Director ies

Directories can be read by anyone who has access permission to read the directory. But only the kernel can write to a directory, to preserve file system sanity.

To simplify the process of reading a directory,aset of directory routines were developed and are part of POSIX.1. Many implementations prevent applications from using the read function to access the contents of directories, thereby further isolating applications from the implementation-specific details of directory formats.

```c
#include <dirent.h>
DIR *opendir(const char *pathname);
DIR *fdopendir(int fd);
// Both return: pointer if OK, NULL on error
struct dirent *readdir(DIR *dp);
// Returns: pointer if OK, NULL at end of directory or error
void rewinddir(DIR *dp);
int closedir(DIR *dp);
// Returns: 0 if OK, −1 on error
long telldir(DIR *dp);
// Returns: current location in directory associated with dp
void seekdir(DIR *dp, long loc);
```

The telldir and seekdir functions are not part of the base POSIX.1 standard. They are included in the XSI option in the Single UNIX Specification, so all conforming UNIX System implementations are expected to provide them.

The dirent structure defined in <dirent.h> is implementation dependent.
Implementations define the structure to contain at least the following two members:

```c
ino_t d_ino; /* i-node number */
char d_name[]; /* null-terminated filename */
```

The DIR structure is an internal structure used by these seven functions to maintain information about the directory being read. The purpose of the DIR structure is similar to that of the FILE structure maintained by the standard I/O library.

The pointer to a DIR structure returned by opendir and fdopendir is then used with the other five functions. The opendir function initializes things so that the first readdir returns the first entry in the directory. When the DIR structure is created by fdopendir, the first entry returned by readdir depends on the file offset associated with the file descriptor passed to fdopendir. Note that the ordering of entries within the directory is implementation dependent and is usually not alphabetical.

### 4.23 chdir, fchdir, and getcwd Functions

Every process has a current working directory. This directory is where the search for all relative pathnames starts. When a user logs in to a UNIX system, the current working directory normally starts at the directory specified by the sixth field in the /etc/passwd file — the user ’s home directory. The current working directory is an attribute of a process; the home directory is an attribute of a login name.

We can change the current working directory of the calling process by calling the chdir or fchdir function.

```c
#include <unistd.h>
int chdir(const char *pathname);
int fchdir(int fd);
// Both return: 0 if OK, −1 on error
```

We can specify the new current working directory either as a pathname or through an open file descriptor.

Because the kernel must maintain knowledge of the current working directory, we should be able to fetch its current value. Unfortunately, the kernel doesn’t maintain the full pathname of the directory. Instead, the kernel keeps information about the directory, such as a pointer to the directory’s v-node.

The getcwd function is useful when we have an application that needs to return to the location in the file system where it started out. We can save the starting location by calling getcwd before we change our working directory. After we complete our processing, we can pass the pathname obtained from getcwd to chdir to return to our starting location in the file system.

The fchdir function provides us with an easy way to accomplish this task. Instead of calling getcwd, we can open the current directory and save the file descriptor before we change to a different location in the file system. When we want to return to where we started, we can simply pass the file descriptor to fchdir.

### 4.24 Device Special Files

The two fields st_dev and st_rdev are often confused.

*  Every file system is known by its major and minor device numbers, which are encoded in the primitive system data type dev_t. The major number identifies the device driver and sometimes encodes which peripheral board to communicate with; the minor number identifies the specific subdevice.
*  We can usually access the major and minor device numbers through two macros defined by most implementations: major and minor. Consequently, we don’t care how the two numbers are stored in a dev_t object.
*  The st_dev value for every filename on a system is the device number of the file system containing that filename and its corresponding i-node.
*  Only character special files and block special files have an st_rdev value. This value contains the device number for the actual device.

We expect the devices to be character special files. The output from the program shows that the root directory has a different device number than does the /home/sar directory, which indicates that they are on different file systems. Running the mount(1) command verifies this.

We then use ls to look at the two disk devices reported by mount and the two terminal devices. The two disk devices are block special files, and the two terminal devices are character special files.

### 4.25 Summary of File Access Per mission Bits

We’ve covered all the file access permission bits, some of which serve multiple purposes.

### 4.26 Summary

This chapter has centered on the stat function. We’ve gone through each member in the stat structure in detail. This, in turn, led us to examine all the attributes of UNIX files and directories. We’ve looked at how files and directories might be laid out in a file system, and we’ve seen how to navigate the file system namespace. A thorough understanding of all the properties of files and directories and all the functions that operate on them is essential to UNIX programming.

## Chapter 5. Standard I/O Library

### 5.1 Introduction

In this chapter, we describe the standard I/O library. This library is specified by the ISO C standard because it has been implemented on many operating systems other than the UNIX System. Additional interfaces are defined as extensions to the ISO C standard by the Single UNIX Specification.

The standard I/O library handles such details as buffer allocation and performing I/O in optimal-sized chunks, obviating our need to worry about using the correct block size. This makes the library easy to use, but at the same time introduces another set of problems if we’re not cognizant of what’s going on.

### 5.2 Streams and FILE Objects

With the standard I/O library, the discussion centers on streams. When we open or create a file with the standard I/O library, we say that we have associated a stream with the file.

With the ASCII character set, a single character is represented by a single byte. With international character sets, a character can be represented by more than one byte. Standard I/O file streams can be used with both single-byte and multibyte (‘‘wide’’) character sets. A stream’s orientation determines whether the characters that are read and written are single byte or multibyte. Initially, when a stream is created, it has no orientation. If a multibyte I/O function (see <wchar.h>) is used on a stream without orientation, the stream’s orientation is set to wide oriented. If a byte I/O function is used on a stream without orientation, the stream’s orientation is set to byte oriented. Only two functions can change the orientation once set. The freopen function (discussed shortly) will clear a stream’s orientation; the fwide function can be used to set a stream’s orientation.

```c
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fp, int mode);
//Returns: positive if stream is wide oriented, negative if stream is byte oriented, or 0 if stream has no orientation
```

The fwide function performs different tasks, depending on the value of the mode argument.

* If the mode argument is negative, fwide will try to make the specified stream byte oriented.
* If the mode argument is positive, fwide will try to make the specified stream wide oriented.
* If the mode argument is zero, fwide will not try to set the orientation, but will still return a value identifying the stream’s orientation.

Note that fwide will not change the orientation of a stream that is already oriented. Also note that there is no error return. Consider what would happen if the stream is invalid. The only recourse we have is to clear errno before calling fwide and check the value of errno when we return. Throughout the rest of this book, we will deal only with byte-oriented streams.

When we open a stream, the standard I/O function fopen returns a pointer to a FILE object. This object is normally a structure that contains all the information required by the standard I/O library to manage the stream: the file descriptor used for actual I/O, a pointer to a buffer for the stream, the size of the buffer, a count of the number of characters currently in the buffer, an error flag, and the like.

Application software should never need to examine a FILE object. To reference the stream, we pass its FILE pointer as an argument to each standard I/O function. Throughout this text, we’ll refer to a pointer to a FILE object, the type FILE *, as a file pointer.

Throughout this chapter, we describe the standard I/O library in the context of a UNIX system. As we mentioned, this library has been ported to a wide variety of other operating systems. To provide some insight about how this library can be implemented, we will talk about its typical implementation on a UNIX system.

### 5.3 Standard Input, Standard Output, and Standard Error

Three streams are predefined and automatically available to a process: standard input, standard output, and standard error. These streams refer to the same files as the file descriptors STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO, respectively.

These three standard I/O streams are referenced through the predefined file pointers stdin, stdout, and stderr. The file pointers are defined in the <stdio.h> header.

### 5.4 Buffer ing

The goal of the buffering provided by the standard I/O library is to use the minimum number of read and write calls. Also, this library tries to do its buffering automatically for each I/O stream, obviating the need for the application to worry about it. Unfortunately, the single aspect of the standard I/O library that generates the most confusion is its buffering.

Three types of buffering are provided:

1. Fully buffered. In this case, actual I/O takes place when the standard I/O buffer is filled. Files residing on disk are normally fully buffered by the standard I/O library. The buffer used is usually obtained by one of the standard I/O functions calling malloc (Section 7.8) the first time I/O is performed on a stream. The term flush describes the writing of a standard I/O buffer. A buffer can be flushed automatically by the standard I/O routines, such as when a buffer fills, or we can call the function fflush to flush a stream. Unfortunately, in the UNIX environment, flush means two different things. In terms of the standard I/O library, it means writing out the contents of a buffer, which may be partially filled. In terms of the terminal driver, it means to discard the data that’s already stored in a buffer
2. Line buffered. In this case, the standard I/O library performs I/O when a newline character is encountered on input or output. This allows us to output a single character at a time (with the standard I/O fputc function), knowing that actual I/O will take place only when we finish writing each line. Line buffering is typically used on a stream when it refers to a terminal—standard input and standard output, for example. Line buffering comes with two caveats. First, the size of the buffer that the standard I/O library uses to collect each line is fixed, so I/O might take place if we fill this buffer before writing a newline. Second, whenever input is requested through the standard I/O library from either (a) an unbuffered stream or (b) a line-buffered stream (that requires data to be requested from the kernel), all line-buffered output streams are flushed. The reason for the qualifier on (b) is that the requested data may already be in the buffer, which doesn’t require data to be read from the kernel. Obviously, any input from an unbuffered stream, item (a), requires data to be obtained from the kernel.
3. Unbuffered. The standard I/O library does not buffer the characters. If we write 15 characters with the standard I/O fputs function, for example, we expect these 15 characters to be output as soon as possible, probably with the write function from Section 3.8. The standard error stream, for example, is normally unbuffered so that any error messages are displayed as quickly as possible, regardless of whether they contain a newline.

ISO C requires the following buffering characteristics:

* Standard input and standard output are fully buffered, if and only if they do not refer to an interactive device.
* Standard error is never fully buffered.

Most implementations default to the following types of buffering:

* Standard error is always unbuffered.
* All other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.

If we don’t like these defaults for any given stream, we can change the buffering by calling either the setbuf or setvbuf function.

```c
#include <stdio.h>
void setbuf(FILE *restrict fp, char *restrict buf );
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
// Returns: 0 if OK, nonzero on error
```

These functions must be called after the stream has been opened (obviously, since each requires a valid file pointer as its first argument) but before any other operation is performed on the stream.

With setbuf, we can turn buffering on or off. To enable buffering, buf must point to a buffer of length BUFSIZ,aconstant defined in <stdio.h>. Normally, the stream is then fully buffered, but some systems may set line buffering if the stream is associated with a terminal device. To disable buffering, we set buf to NULL.

With setvbuf, we specify exactly which type of buffering we want. This is done
with the mode argument:

_IOFBF fully buffered
_IOLBF line buffered
_IONBF unbuffered

If we specify an unbuffered stream, the buf and size arguments are ignored. If we specify fully buffered or line buffered, buf and size can optionally specify a buffer and its size. If the stream is buffered and buf is NULL, the standard I/O library will automatically allocate its own buffer of the appropriate size for the stream. By appropriate size, we mean the value specified by the constant BUFSIZ.

Be aware that if we allocate a standard I/O buffer as an automatic variable within a function, we have to close the stream before returning from the function.  Also, some implementations use part of the buffer for internal bookkeeping, so the actual number of bytes of data that can be stored in the buffer can be less than size. In general, we should let the system choose the buffer size and automatically allocate the buffer. When we do this, the standard I/O library automatically releases the buffer when we close the stream.

At any time, we can force a stream to be flushed.

```c
#include <stdio.h>
int fflush(FILE *fp);
// Returns: 0 if OK, EOF on error
```

The fflush function causes any unwritten data for the stream to be passed to the kernel. As a special case, if fp is NULL, fflush causes all output streams to be flushed.

### 5.5 Opening a Stream

The fopen, freopen, and fdopen functions open a standard I/O stream.

```c
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type,
FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
// All three return: file pointer if OK, NULL on error
```

The differences in these three functions are as follows:

1. The fopen function opens a specified file.
2. The freopen function opens a specified file on a specified stream, closing the stream first if it is already open. If the stream previously had an orientation, freopen clears it. This function is typically used to open a specified file as one of the predefined streams: standard input, standard output, or standard error.
3. The fdopen function takes an existing file descriptor, which we could obtain from the open, dup, dup2, fcntl, pipe, socket, socketpair, or accept functions, and associates a standard I/O stream with the descriptor. This function is often used with descriptors that are returned by the functions that create pipes and network communication channels. Because these special types of files cannot be opened with the standard I/O fopen function, we have to call the device-specific function to obtain a file descriptor, and then associate this descriptor with a standard I/O stream using fdopen.

type  | Description  | open(2) Flags
------------ | ------------- | -------------
r or rb  | open for reading  | O_RDONLY
w or wb  | truncate to 0 length or create for writing  | O_WRONLY, O_CREAT, O_TRUNC
a or ab  | append; open for writing at end of file, or create for writing |  O_WRONLY, O_CREAT, O_APPEND
r+ or r+b or rb+  | open for reading and writing  | O_RDWR
w+ or w+b or wb+  | truncate to 0 length or create for reading and writing  | O_RDWR, O_CREAT, O_TRUNC
a+ or a+b or ab+  | open or create for reading and writing at end of file  | O_RDWR, O_CREAT, O_APPEND

Using the character b as part of the type allows the standard I/O system to differentiate between a text file and a binary file. Since the UNIX kernel doesn’t differentiate between these types of files, specifying the character b as part of the type has no effect.

With fdopen, the meanings of the type argument differ slightly. The descriptor has already been opened, so opening for writing does not truncate the file. (If the descriptor was created by the open function, for example, and the file already existed, the O_TRUNC flag would control whether the file was truncated. The fdopen function cannot simply truncate any file it opens for writing.) Also, the standard I/O append mode cannot create the file (since the file has to exist if a descriptor refers to it).

When a file is opened with a type of append, each write will take place at the then current end of file. If multiple processes open the same file with the standard I/O append mode, the data from each process will be correctly written to the file.

When a file is opened for reading and writing (the plus sign in the type), two restrictions apply.

* Output cannot be directly followed by input without an intervening fflush, fseek, fsetpos, or rewind.
* Input cannot be directly followed by output without an intervening fseek, fsetpos, or rewind, or an input operation that encounters an end of file.

POSIX.1 requires implementations to create the file with the following permissions bit set:
`S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH`

By default, the stream that is opened is fully buffered, unless it refers to a terminal device, in which case it is line buffered. Once the stream is opened, but before we do any other operation on the stream, we can change the buffering if we want to, with the setbuf or setvbuf functions from the previous section.

An open stream is closed by calling fclose.

```c
#include <stdio.h>
int fclose(FILE *fp);
// Returns: 0 if OK, EOF on error
```

Any buffered output data is flushed before the file is closed. Any input data that may be buffered is discarded. If the standard I/O library had automatically allocated a buffer for the stream, that buffer is released.

When a process terminates normally, either by calling the exit function directly or by returning from the main function, all standard I/O streams with unwritten buffered data are flushed and all open standard I/O streams are closed.

### 5.6 Reading and Writing a Stream

Once we open a stream, we can choose from among three types of unformatted I/O:

1. Character-at-a-time I/O. We can read or write one character at a time, with the standard I/O functions handling all the buffering, if the stream is buffered.
2. Line-at-a-time I/O. If we want to read or write a line at a time, we use fgets and fputs. Each line is terminated with a newline character, and we have to specify the maximum line length that we can handle when we call fgets. 
3. Direct I/O. This type of I/O is supported by the fread and fwrite functions. For each I/O operation, we read or write some number of objects, where each object is of a specified size. These two functions are often used for binary files where we read or write a structure with each operation. 

Three functions allow us to read one character at a time.

```c
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
// All three return: next character if OK, EOF on end of file or error
```

The function getchar is defined to be equivalent to getc(stdin). The difference between getc and fgetc is that getc can be implemented as a macro, whereas fgetc cannot be implemented as a macro. This means three things.

1. The argument to getc should not be an expression with side effects, because it could be evaluated more than once.
2. Since fgetc is guaranteed to be a function, we can take its address. This allows us to pass the address of fgetc as an argument to another function.
3. Calls to fgetc probably take longer than calls to getc, as it usually takes more time to call a function.

These three functions return the next character as an unsigned char converted to an int. The reason for specifying unsigned is so that the high-order bit, if set, doesn’t cause the return value to be negative. The reason for requiring an integer return value is so that all possible character values can be returned, along with an indication that either an error occurred or the end of file has been encountered. The constant EOF in <stdio.h> is required to be a negative value. Its value is often −1. This representation also means that we cannot store the return value from these three functions in a character variable and later compare this value with the constant EOF.

Note that these functions return the same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call either ferror or feof.

```c
#include <stdio.h>
int ferror(FILE *fp);
int feof(FILE *fp);
// Both return: nonzero (true) if condition is true, 0 (false) otherwise
void clearerr(FILE *fp);
```

In most implementations, two flags are maintained for each stream in the FILE object:

* An error flag
* An end-of-file flag

Both flags are cleared by calling clearerr.

After reading from a stream, we can push back characters by calling ungetc.

```c
#include <stdio.h>
int ungetc(int c, FILE *fp);
// Returns: c if OK, EOF on error
```

The characters that are pushed back are returned by subsequent reads on the stream in reverse order of their pushing. Be aware, however, that although ISO C allows an implementation to support any amount of pushback, an implementation is required to provide only a single character of pushback. We should not count on more than a single character.

The character that we push back does not have to be the same character that was read. We are not able to push back EOF. When we reach the end of file, however, we can push back a character. The next read will return that character, and the read after that will return EOF. This works because a successful call to ungetc clears the end-offile indication for the stream.

Pushback is often used when we’re reading an input stream and breaking the input into words or tokens of some form. Sometimes we need to peek at the next character to determine how to handle the current character. It’s then easy to push back the character that we peeked at, for the next call to getc to return. If the standard I/O library didn’t provide this pushback capability, we would have to store the character in a variable of our own, along with a flag telling us to use this character instead of calling getc the next time we need a character.

Output functions are available that correspond to each of the input functions we’ve already described.

```c
#include <stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
// All three return: c if OK, EOF on error
```

As with the input functions, putchar(c) is equivalent to putc(c, stdout), and putc can be implemented as a macro, whereas fputc cannot be implemented as a macro.

### 5.7 Line-at-a-Time I/O

Line-at-a-time input is provided by the two functions, fgets and gets.

```c
#include <stdio.h>
char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf );
// Both return: buf if OK, NULL on end of file or error
```

Both specify the address of the buffer to read the line into. The gets function reads from standard input, whereas fgets reads from the specified stream.

With fgets, we have to specify the size of the buffer, n. This function reads up through and including the next newline, but no more than n − 1 characters, into the buffer. The buffer is terminated with a null byte. If the line, including the terminating newline, is longer than n − 1, only a partial line is returned, but the buffer is always null terminated. Another call to fgets will read what follows on the line.

The gets function should never be used. The problem is that it doesn’t allow the caller to specify the buffer size. This allows the buffer to overflow if the line is longer than the buffer, writing over whatever happens to follow the buffer in memory.

Even though ISO C requires an implementation to provide gets, you should use fgets instead. In fact, gets is marked as an obsolescent interface in SUSv4 and has been omitted from the latest version of the ISO C standard.

Line-at-a-time output is provided by fputs and puts.

```c
#include <stdio.h>
int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
// Both return: non-negative value if OK, EOF on error
```

The function fputs writes the null-terminated string to the specified stream. The null byte at the end is not written. Note that this need not be line-at-a-time output, since the string need not contain a newline as the last non-null character. Usually, this is the case — the last non-null character is a newline—but it’s not required.

The puts function writes the null-terminated string to the standard output, without writing the null byte. But puts then writes a newline character to the standard output.

The puts function is not unsafe, like its counterpart gets. Nevertheless, we’ll avoid using it, to prevent having to remember whether it appends a newline. If we always use fgets and fputs, we know that we always have to deal with the newline character at the end of each line.

### 5.8 Standard I/O Efficiency

Using the functions from the previous section, we can get an idea of the efficiency of the standard I/O system.

We can make another version of this program that uses fgetc and fputc, which should be functions, not macros.

Instead, we know that the exit function will flush any unwritten data and then close all open streams.

The system CPU time is about the same as before, because roughly the same number of kernel requests are being made. One advantage of using the standard I/O routines is that we don’t have to worry about buffering or choosing the optimal I/O size. We do have to determine the maximum line size for the version that uses fgets, but that’s easier than trying to choose the optimal I/O size.

We can see that the version using getc and putc takes the same amount of space as the one using the fgetc and fputc functions. Usually, getc and putc are implemented as macros, but in the GNU C library implementation the macro simply expands to a function call.

The version using line-at-a-time I/O is almost twice as fast as the version using character-at-a-time I/O. If the fgets and fputs functions are implemented using getc and putc, then we would expect the timing to be similar to the getc version. Actually, we might expect the line-at-a-time version to take longer, since we would be adding the overhead of 200 million extra function calls to the existing 6 million ones. What is happening with this example is that the line-at-a-time functions are implemented using memccpy(3). Often, the memccpy function is implemented in assembly language instead of C, for efficiency.

Both involve the same number of function calls—about 200 million—yet the fgetc version is more than 16 times faster in terms of user CPU time and almost 39 times faster in terms of clock time. The difference is that the version using read executes 200 million function calls, which in turn execute 200 million system calls. With the fgetc version, we still execute 200 million function calls, but this translates into only 25,224 system calls. System calls are usually much more expensive than ordinary function calls.

### 5.9 Binary I/O

If we’re doing binary I/O, we often would like to read or write an entire structure at a time. To do this using getc or putc, we have to loop through the entire structure, one byte at a time, reading or writing each byte. We can’t use the line-at-a-time functions, since fputs stops writing when it hits a null byte, and there might be null bytes within the structure. Similarly, fgets won’t work correctly on input if any of the data bytes are nulls or newlines. Therefore, the following two functions are provided for binary I/O.

```c
#include <stdio.h>
size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
// Both return: number of objects read or written
```

These functions have two common uses:

1. Read or write a binary array. For example, to write elements 2 through 5 of a floating-point array, we could write

```c
float data[10];
if (fwrite(&data[2], sizeof(float), 4, fp) != 4) err_sys("fwrite error");
```

Here, we specify size as the size of each element of the array and nobj as the
number of elements.

2. Read or write a structure. For example, we could write

```c
struct {
    short count;
    long total;
    char name[NAMESIZE];
} item;
if (fwrite(&item, sizeof(item), 1, fp) != 1) err_sys("fwrite error");
```

Here, we specify size as the size of structure and nobj as 1 (the number of objects to write).

The obvious generalization of these two cases is to read or write an array of structures. To do this, size would be the sizeof the structure, and nobj would be the number of elements in the array.

Both fread and fwrite return the number of objects read or written. For the read case, this number can be less than nobj if an error occurs or if the end of file is encountered. In this situation, ferror or feof must be called. For the write case, if the return value is less than the requested nobj, an error has occurred.

A fundamental problem with binary I/O is that it can be used to read only data that has been written on the same system. This was OK many years ago, when all the UNIX systems were PDP-11s, but the norm today is to have heterogeneous systems connected together with networks. It is common to want to write data on one system and process it on another. These two functions won’t work, for two reasons.

1. The offset of a member within a structure can differ between compilers and systems because of different alignment requirements. Indeed, some compilers have an option allowing structures to be packed tightly, to save space with a possible runtime performance penalty, or aligned accurately, to optimize runtime access of each member. This means that even on a single system, the binary layout of a structure can differ, depending on compiler options.
2. The binary formats used to store multibyte integers and floating-point values differ among machine architectures.

### 5.10 Positioning a Stream

There are three ways to position a standard I/O stream:

1. The two functions ftell and fseek. They have been around since Version 7, but they assume that a file’s position can be stored in a long integer.
2. The two functions ftello and fseeko. They were introduced in the Single UNIX Specification to allow for file offsets that might not fit in a long integer. They replace the long integer with the off_t data type.
3. The two functions fgetpos and fsetpos. They were introduced by ISO C. They use an abstract data type, fpos_t, that records a file’s position. This data type can be made as big as necessary to recordafile’s position.

When porting applications to non-UNIX systems, use fgetpos and fsetpos.

```c
#include <stdio.h>
long ftell(FILE *fp);
// Returns: current file position indicator if OK, −1L on error
int fseek(FILE *fp, long offset, int whence);
// Returns: 0 if OK, −1 on error
void rewind(FILE *fp);
```

For a binary file, a file’s position indicator is measured in bytes from the beginning of the file. The value returned by ftell for a binary file is this byte position. To position a binary file using fseek, we must specify a byte offset and indicate how that offset is interpreted.

For text files, the file’s current position may not be measurable as a simple byte offset. Again, this is mainly under non-UNIX systems that might store text files in a different format. To position a text file, whence has to be SEEK_SET, and only two values for offset are allowed: 0—meaning rewind the file to its beginning—oravalue that was returned by ftell for that file. A stream can also be set to the beginning of the file with the rewind function.

The ftello function is the same as ftell, and the fseeko function is the same as fseek, except that the type of the offset is off_t instead of long.

```c
#include <stdio.h>
off_t ftello(FILE *fp);
// Returns: current file position indicator if OK, (off_t)−1 on error
int fseeko(FILE *fp, off_t offset, int whence);
// Returns: 0 if OK, −1 on error
```

As we mentioned earlier, the fgetpos and fsetpos functions were introduced by the ISO C standard.

```c
#include <stdio.h>
int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
int fsetpos(FILE *fp, const fpos_t *pos);
// Both return: 0 if OK, nonzero on error
```

The fgetpos function stores the current value of the file’s position indicator in the object pointed to by pos. This value can be used in a later call to fsetpos to reposition the stream to that location.

### 5.11 For matted I/O

Formatted output is handled by the five printf functions.

```c
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);
int dprintf(int fd, const char *restrict format, ...);
// All three return: number of characters output if OK, negative value if output error
int sprintf(char *restrict buf, const char *restrict format, ...);
// Returns: number of characters stored in array if OK, negative value if encoding error
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
// Returns: number of characters that would have been stored in array if buffer was large enough, negative value if encoding error
```

The printf function writes to the standard output, fprintf writes to the specified stream, dprintf writes to the specified file descriptor, and sprintf places the formatted characters in the array buf. The sprintf function automatically appends a null byte at the end of the array, but this null byte is not included in the return value.

Note that it’s possible for sprintf to overflow the buffer pointed to by buf. The caller is responsible for ensuring that the buffer is large enough. Because buffer overflows can lead to program instability and even security violations, snprintf was introduced. With it, the size of the buffer is an explicit parameter; any characters that would have been written past the end of the buffer are discarded instead. The snprintf function returns the number of characters that would have been written to the buffer had it been big enough. As with sprintf, the return value doesn’t include the terminating null byte. If snprintf returns a positive value less than the buffer size n, then the output was not truncated. If an encoding error occurs, snprintf returns a negative value.

Although dprintf doesn’t deal with a file pointer, we include it with the rest of the related functions that handle formatted output. Note that using dprintf removes the need to call fdopen to convert a file descriptor into a file pointer for use with fprintf.

The format specification controls how the remainder of the arguments will be encoded and ultimately displayed. Each argument is encoded according to a conversion specification that starts with a percent sign (%). Except for the conversion specifications, other characters in the format are copied unmodified. A conversion specification has four optional components, shown in square brackets below: 
`%[flags][fldwidth][precision][lenmodifier]convtype`

The fldwidth component specifies a minimum field width for the conversion. If the conversion results in fewer characters, it is padded with spaces. The field width is a non-negative decimal integer or an asterisk.

The precision component specifies the minimum number of digits to appear for integer conversions, the minimum number of digits to appear to the right of the decimal point for floating-point conversions, or the maximum number of bytes for string conversions. The precision is a period (.) followed by a optional non-negative decimal integer or an asterisk.

Either the field width or precision (or both) can be an asterisk. In this case, an integer argument specifies the value to be used. The argument appears directly before the argument to be converted.

The lenmodifier component specifies the size of the argument. The convtype component is not optional. It controls how the argument is interpreted.

With the normal conversion specification, conversions are applied to the arguments in the order they appear after the format argument. An alternative conversion specification syntax allows the arguments to be named explicitly with the sequence %n$ representing the nth argument. Note, however, that the two syntaxes can’t be mixed in the same format specification. With the alternative syntax, arguments are numbered starting at one. If either the field width or precision is to be supplied by an argument, the asterisk syntax is modified to *m$, where m specifies the position of the argument supplying the value.

The following five variants of the printf family are similar to the previous five, but the variable argument list (...) is replaced with arg.

```c
#include <stdarg.h>
#include <stdio.h>
int vprintf(const char *restrict format, va_list arg);
int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg);
int vdprintf(int fd, const char *restrict format, va_list arg);
// All three return: number of characters output if OK, negative value if output error
int vsprintf(char *restrict buf, const char *restrict format, va_list arg);
// Returns: number of characters stored in array if OK, negative value if encoding error
int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg);
// Returns: number of characters that would have been stored in array if buffer was large enough, negative value if encoding error
```

Formatted input is handled by the three scanf functions.

```c
#include <stdio.h>
int scanf(const char *restrict format, ...);
int fscanf(FILE *restrict fp, const char *restrict format, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);
// All three return: number of input items assigned, EOF if input error or end of file before any conversion
```

The scanf family is used to parse an input string and convert character sequences into variables of specified types. The arguments following the format contain the addresses of the variables to initialize with the results of the conversions.

The format specification controls how the arguments are converted for assignment. The percent sign (%) indicates the beginning of a conversion specification. Except for the conversion specifications and white space, other characters in the format have to match the input. If a character doesn’t match, processing stops, leaving the remainder of the input unread.

There are three optional components to a conversion specification, shown in square brackets below:
`%[*][fldwidth][m][lenmodifier]convtype`

The optional leading asterisk is used to suppress conversion. Input is converted as specified by the rest of the conversion specification, but the result is not stored in an argument.

The fldwidth component specifies the maximum field width in characters. The lenmodifier component specifies the size of the argument to be initialized with the result of the conversion. The same length modifiers supported by the printf family of functions are supported by the scanf family of functions.

The convtype field is similar to the conversion type field used by the printf family, but there are some differences. One difference is that results that are stored in unsigned types can optionally be signed on input. For example, −1 will scan as 4294967295 into an unsigned integer.

The optional m character between the field width and the length modifier is called the assignment-allocation character. It can be used with the %c, %s, and %[ conversion specifiers to force a memory buffer to be allocated to hold the converted string. In this case, the corresponding argument should be the address of a pointer to which the address of the allocated buffer will be copied. If the call succeeds, the caller is responsible for freeing the buffer by calling the free function when the buffer is no longer needed.

The scanf family of functions also supports the alternative conversion specification syntax allowing the arguments to be named explicitly: the sequence %n$ represents the nth argument. With the printf family of functions, the same numbered argument can be referenced in the format string more than once. In this case, however, the Single UNIX Specification states that the behavior is undefined with the scanf family of functions.

Like the printf family, the scanf family supports functions that use variable argument lists as specified by <stdarg.h>.

```c
#include <stdarg.h>
#include <stdio.h>
int vscanf(const char *restrict format, va_list arg);
int vfscanf(FILE *restrict fp, const char *restrict format, va_list arg);
int vsscanf(const char *restrict buf, const char *restrict format, va_list arg);
// All three return: number of input items assigned, EOF if input error or end of file before any conversion
```

Refer to your UNIX system manual for additional details on the scanf family of functions.

### 5.12 Implementation Details

Each standard I/O stream has an associated file descriptor, and we can obtain the descriptor for a stream by calling fileno.

```c
#include <stdio.h>
int fileno(FILE *fp);
// Returns: the file descriptor associated with the stream
```

We need this function if we want to call the dup or fcntl functions, for example. To look at the implementation of the standard I/O library on your system, start with the header <stdio.h>. This will show how the FILE object is defined, the definitions of the per-stream flags, and any standard I/O routines, such as getc, that are defined as macros.

Note that we perform I/O on each stream before printing its buffering status, since the first I/O operation usually causes the buffers to be allocated for a stream. The structure members and the constants used in this example are defined by the implementations of the standard I/O library used on the four platforms described in this book. Be aware that implementations of the standard I/O library vary, and programs like this example are nonportable, since they embed knowledge specific to particular implementations.

We can see that the default for this system is to have standard input and standard output line buffered when they’re connected to a terminal. The line buffer is 1,024 bytes. Note that this doesn’t restrict us to 1,024-byte input and output lines; that’s just the size of the buffer. Writing a 2,048-byte line to standard output will require two write system calls. When we redirect these two streams to regular files, they become fully buffered, with buffer sizes equal to the preferred I/O size—the st_blksize value from the stat structure—for the file system. We also see that the standard error is always unbuffered, as it should be, and that a regular file defaults to fully buffered.

### 5.13 Temporary Files

The ISO C standard defines two functions that are provided by the standard I/O library to assist in creating temporary files.

```c
#include <stdio.h>
char *tmpnam(char *ptr);
// Returns: pointer to unique pathname
FILE *tmpfile(void);
// Returns: file pointer if OK, NULL on error
```

The tmpnam function generates a string that is a valid pathname and that does not match the name of any existing file. This function generates a different pathname each time it is called, up to TMP_MAX times. TMP_MAX is defined in <stdio.h>.

If ptr is NULL, the generated pathname is stored in a static area, and a pointer to this area is returned as the value of the function. Subsequent calls to tmpnam can overwrite this static area. (Thus, if we call this function more than once and we want to save the pathname, we have to save a copy of the pathname, not a copy of the pointer.) If ptr is not NULL, it is assumed that it points to an array of at least L_tmpnam characters. (The constant L_tmpnam is defined in <stdio.h>.) The generated pathname is stored in this array, and ptr is returned as the value of the function.

The tmpfile function creates a temporary binary file (type wb+) that is automatically removed when it is closed or on program termination. Under the UNIX System, it makes no difference that this file is a binary file.

The standard technique often used by the tmpfile function is to create a unique pathname by calling tmpnam, then create the file, and immediately unlink it.

The Single UNIX Specification defines two additional functions as part of the XSI option for dealing with temporary files: mkdtemp and mkstemp.

```c
#include <stdlib.h>
char *mkdtemp(char *template);
// Returns: pointer to directory name if OK, NULL on error
int mkstemp(char *template);
// Returns: file descriptor if OK, −1 on error
```

The mkdtemp function creates a directory with a unique name, and the mkstemp function creates a regular file with a unique name. The name is selected using the template string. This string is a pathname whose last six characters are set to XXXXXX. The function replaces these placeholders with different characters to create a unique pathname. If successful, these functions modify the template string to reflect the name of the temporary file.

The directory created by mkdtemp is created with the following access permission bits set: S_IRUSR | S_IWUSR | S_IXUSR. Note that the file mode creation mask of the calling process can restrict these permissions further. If directory creation is successful, mkdtemp returns the name of the new directory.

The mkstemp function creates a regular file with a unique name and opens it. The file descriptor returned by mkstemp is open for reading and writing. The file created by mkstemp is created with access permissions S_IRUSR | S_IWUSR.

Unlike tmpfile, the temporary file created by mkstemp is not removed automatically for us. If we want to remove it from the file system namespace, we need to unlink it ourselves.

Use of tmpnam and tempnam does have at least one drawback: a window exists between the time that the unique pathname is returned and the time that an application creates a file with that name. During this timing window, another process can create a file of the same name. The tmpfile and mkstemp functions should be used instead, as they don’t suffer from this problem.

The difference in behavior comes from the way the two template strings are declared. For the first template, the name is allocated on the stack, because we use an array variable. For the second name, however, we use a pointer. In this case, only the memory for the pointer itself resides on the stack; the compiler arranges for the string to be stored in the read-only segment of the executable. When the mkstemp function tries to modify the string, a segmentation fault occurs.

### 5.14 Memory Streams

As we’ve seen, the standard I/O library buffers data in memory, so operations such as character-at-a-time I/O and line-at-a-time I/O are more efficient. We’ve also seen that we can provide our own buffer for the library to use by calling setbuf or setvbuf. In Version 4, the Single UNIX Specification added support for memory streams. These are standard I/O streams for which there are no underlying files, although they are still accessed with FILE pointers. All I/O is done by transferring bytes to and from buffers in main memory. As we shall see, even though these streams look like file streams, several features make them more suited for manipulating character strings.

Three functions are available to create memory streams. The first is fmemopen.

```c
#include <stdio.h>
FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);
// Returns: stream pointer if OK, NULL on error
```

The fmemopen function allows the caller to provide a buffer to be used for the memory stream: the buf argument points to the beginning of the buffer and the size argument specifies the size of the buffer in bytes. If the buf argument is null, then the fmemopen function allocates a buffer of size bytes. In this case, the buffer will be freed when the stream is closed.

The type argument controls how the stream can be used.

type | Description
------ | ------
r or rb  | open for reading
w or wb  | open for writing
a or ab  | append; open for writing at first null byte
r+ or r+b or rb+  | open for reading and writing
w+ or w+b or wb+  | truncate to 0 length and open for reading and writing
a+ or a+b or ab+  | append; open for reading and writing at first null byte

Note that these values correspond to the ones for file-based standard I/O streams, but there are some subtle differences. First, whenever a memory stream is opened for append, the current file position is set to the first null byte in the buffer. If the buffer contains no null bytes, then the current position is set to one byte past the end of the buffer. When a stream is not opened for append, the current position is set to the beginning of the buffer. Because the append mode determines the end of the data by the first null byte, memory streams aren’t well suited for storing binary data (which might contain null bytes before the end of the data).

Second, if the buf argument is a null pointer, it makes no sense to open the stream for only reading or only writing. Because the buffer is allocated by fmemopen in this case, there is no way to find the buffer’s address, so to open the stream only for writing means we could never read what we’ve written. Similarly, to open the stream only for reading means we can only read the contents of a buffer into which we can never write.

Third, a null byte is written at the current position in the stream whenever we increase the amount of data in the stream’s buffer and call fclose, fflush, fseek, fseeko, or fsetpos.

The other two functions that can be used to create a memory stream are open_memstream and open_wmemstream.

```c
#include <stdio.h>
FILE *open_memstream(char **bufp, size_t *sizep);
#include <wchar.h>
FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);
// Both return: stream pointer if OK, NULL on error
```

The open_memstream function creates a stream that is byte oriented, and the open_wmemstream function creates a stream that is wide oriented. These two functions differ from fmemopen in several ways:

* The stream created is only open for writing.
* We can’t specify our own buffer, but we can get access to the buffer ’s address and size through the bufp and sizep arguments, respectively.
* We need to free the buffer ourselves after closing the stream.
* The buffer will grow as we add bytes to the stream.

We must follow some rules, however, regarding the use of the buffer address and its length. First, the buffer address and length are only valid after a call to fclose or fflush. Second, these values are only valid until the next write to the stream or a call to fclose. Because the buffer can grow, it may need to be reallocated. If this happens, then we will find that the value of the buffer ’s memory address will change the next time we call fclose or fflush.

Memory streams are well suited for creating strings, because they prevent buffer overflows. They can also provide a performance boost for functions that take standard I/O stream arguments used for temporary files, because memory streams access only main memory instead of a file stored on disk.

### 5.15 Alternatives to Standard I/O



### 5.16 Summary



## Chapter 6. System Data Files and Information



### 6.1 Introduction



### 6.2 Password File



### 6.3 Shadow Passwords



### 6.4 Group File



### 6.5 Supplementary Group IDs



### 6.6 Implementation Differences



### 6.7 Other Data Files



### 6.8 Login Accounting



### 6.9 System Identification



### 6.10 Time and Date Routines



### 6.11 Summary



## Chapter 7. Process Environment



### 7.1 Introduction



### 7.2 main Function



### 7.3 Process Termination



### 7.4 Command-Line Arguments



### 7.5 Environment List



### 7.6 Memory Lay out of a C Program



### 7.7 Shared Librar ies



### 7.8 Memory Allocation



### 7.9 Environment Var iables



### 7.10 setjmp and longjmp Functions



### 7.11 getrlimit and setrlimit Functions



### 7.12 Summary



## Chapter 8. Process Control



### 8.1 Introduction



### 8.2 Process Identifiers



### 8.3 fork Function



### 8.4 vfork Function



### 8.5 exit Functions



### 8.6 wait and waitpid Functions



### 8.7 waitid Function



### 8.8 wait3 and wait4 Functions



### 8.9 Race Conditions



### 8.10 exec Functions



### 8.11 Changing User IDs and Group IDs



### 8.12 Interpreter Files



### 8.13 system Function



### 8.14 Process Accounting



### 8.15 User Identification



### 8.16 Process Scheduling



### 8.17 Process Times



### 8.18 Summary



## Chapter 9. Process Relationships



### 9.1 Introduction



### 9.2 Ter minal Logins



### 9.3 Networ k Logins



### 9.4 Process Groups



### 9.5 Sessions



### 9.6 Controlling Terminal



### 9.7 tcgetpgrp, tcsetpgrp, and tcgetsid Functions



### 9.8 Job Control



### 9.9 Shell Execution of Programs



### 9.10 Orphaned Process Groups



### 9.11 FreeBSD Implementation



### 9.12 Summary



## Chapter 10. Signals



### 10.1 Introduction



### 10.2 Signal Concepts



### 10.3 signal Function



### 10.4 Unreliable Signals



### 10.5 Interrupted System Calls



### 10.6 Reentrant Functions



### 10.7 SIGCLD Semantics



### 10.8 Reliable-Signal Ter minology and Semantics



### 10.9 kill and raise Functions



### 10.10 alarm and pause Functions



### 10.11 Signal Sets



### 10.12 sigprocmask Function



### 10.13 sigpending Function



### 10.14 sigaction Function



### 10.15 sigsetjmp and siglongjmp Functions



### 10.16 sigsuspend Function



### 10.17 abort Function



### 10.18 system Function



### 10.19 sleep, nanosleep, and clock_nanosleep Functions



### 10.20 sigqueue Function



### 10.21 Job-Control Signals



### 10.22 Signal Names and Numbers



### 10.23 Summary



## Chapter 11. Threads



### 11.1 Introduction



### 11.2 Thread Concepts



### 11.3 Thread Identification



### 11.4 Thread Creation



### 11.5 Thread Termination



### 11.6 Thread Synchronization



### 11.6.1 Mutexes



### 11.6.2 Deadlock Avoidance



### 11.6.3 pthread_mutex_timedlock Function



### 11.6.4 Reader–Writer Locks



### 11.6.5 Reader–Writer Locking with Timeouts



### 11.6.6 Condition Variables



### 11.6.7 Spin Locks



### 11.6.8 Barriers



### 11.7 Summary



## Chapter 12. Thread Control



### 12.1 Introduction



### 12.2 Thread Limits



### 12.3 Thread Attr ibutes



### 12.4 Synchronization Attr ibutes



### 12.4.1 Mutex Attr ibutes



### 12.4.2 Reader–Writer Lock Attr ibutes



### 12.4.3 Condition Variable Attributes



### 12.4.4 Barrier Attributes



### 12.5 Reentrancy



### 12.6 Thread-Specific Data



### 12.7 Cancel Options



### 12.8 Threads and Signals



### 12.9 Threads and fork



### 12.10 Threads and I/O



### 12.11 Summary



## Chapter 13. Daemon Processes



### 13.1 Introduction



### 13.2 Daemon Character istics



### 13.3 Coding Rules



### 13.4 Error Logging



### 13.5 Single-Instance Daemons



### 13.6 Daemon Conventions



### 13.7 Client–Server Model



### 13.8 Summary



## Chapter 14. Advanced I/O



### 14.1 Introduction



### 14.2 Nonblocking I/O



### 14.3 Record Locking



### 14.4 I/O Multiplexing



### 14.4.1 select and pselect Functions



### 14.4.2 poll Function



### 14.5 Asynchronous I/O



### 14.5.1 System V Asynchronous I/O



### 14.5.2 BSD Asynchronous I/O



### 14.5.3 POSIX Asynchronous I/O



### 14.6 readv and writev Functions



### 14.7 readn and writen Functions



### 14.8 Memory-Mapped I/O



### 14.9 Summary



## Chapter 15. Interprocess Communication



### 15.1 Introduction



### 15.2 Pipes



### 15.3 popen and pclose Functions



### 15.4 Coprocesses



### 15.5 FIFOs



### 15.6 XSI IPC



### 15.6.1 Identifiers and Keys



### 15.6.2 Per mission Str ucture



### 15.6.3 Configuration Limits



### 15.6.4 Advantages and Disadvantages



### 15.7 Message Queues



### 15.8 Semaphores



### 15.9 Shared Memor y



### 15.10 POSIX Semaphores



### 15.11 Client–Server Proper ties



### 15.12 Summary



## Chapter 16. Network IPC: Sockets



### 16.1 Introduction



### 16.2 Socket Descr iptors



### 16.3 Addressing



### 16.3.1 Byte Order ing



### 16.3.2 Address Formats



### 16.3.3 Address Lookup



### 16.3.4 Associating Addresses with Sockets



### 16.4 Connection Establishment



### 16.5 Data Tr ansfer



### 16.6 Socket Options



### 16.7 Out-of-Band Data



### 16.8 Nonblocking and Asynchronous I/O



### 16.9 Summary



## Chapter 17. Advanced IPC



### 17.1 Introduction



### 17.2 UNIX Domain Sockets



### 17.2.1 Naming UNIX Domain Sockets



### 17.3 Unique Connections



### 17.4 Passing File Descriptors



### 17.5 An Open Server, Version 1



### 17.6 An Open Server, Version 2



### 17.7 Summary



## Chapter 18. Terminal I/O



### 18.1 Introduction



### 18.2 Over view



### 18.3 Special Input Characters



### 18.4 Getting and Setting Ter minal Attr ibutes



### 18.5 Ter minal Option Flags



### 18.6 stty Command



### 18.7 Baud Rate Functions



### 18.8 Line Control Functions



### 18.9 Ter minal Identification



### 18.10 Canonical Mode



### 18.11 Noncanonical Mode



### 18.12 Ter minal Window Size



### 18.13 termcap, terminfo, and curses



### 18.14 Summary



## Chapter 19. Pseudo Terminals



### 19.1 Introduction



### 19.2 Over view



### 19.3 Opening Pseudo-Ter minal Devices



### 19.4 pty_fork Function



### 19.5 pty Program



### 19.6 Using the pty Program



### 19.7 Advanced Features



### 19.8 Summary



## Chapter 20. A Database Library



### 20.1 Introduction



### 20.2 History



### 20.3 The Librar y



### 20.4 Implementation Over view



### 20.5 Centralized or Decentralized?



### 20.6 Concurrency



### 20.7 Building the Librar y



### 20.8 Source Code



### 20.9 Perfor mance



### 20.10 Summary



## Chapter 21. Communicating with a Network Printer



### 21.1 Introduction



### 21.2 The Inter net Pr inting Protocol



### 21.3 The Hyper text Transfer Protocol



### 21.4 Printer Spooling



### 21.5 Source Code



### 21.6 Summary
